pragma solidity >=0.6.0 <0.7.0;contract Exposure is Constants, Controllable, Whitelist, IExposure {using SafeMath for uint256;using SafeERC20 for IERC20;uint256 public protocolCount;uint256 public makerUSDCExposure;event LogNewProtocolCount(uint256 count);event LogNewMakerExposure(uint256 exposure);function setProtocolCount(uint256 _protocolCount) external onlyOwner {protocolCount = _protocolCount;emit LogNewProtocolCount(_protocolCount);}function setMakerUSDCExposure(uint256 _makerUSDCExposure) external onlyOwner {makerUSDCExposure = _makerUSDCExposure;emit LogNewMakerExposure(_makerUSDCExposure);}function getExactRiskExposure(SystemState calldata sysState)externalviewoverridereturns (ExposureState memory expState){expState = _calcRiskExposure(sysState, false);ILifeGuard lifeguard = ILifeGuard(_controller().lifeGuard());IBuoy buoy = IBuoy(_controller().buoy());for (uint256 i = 0; i < N_COINS; i++) {uint256 assets = lifeguard.assets(i);uint256 assetsUsd = buoy.singleStableToUsd(assets, i);expState.stablecoinExposure[i] = expState.stablecoinExposure[i].add(assetsUsd.mul(PERCENTAGE_DECIMAL_FACTOR).div(sysState.totalCurrentAssetsUsd));}}function calcRiskExposure(SystemState calldata sysState)externalviewoverridereturns (ExposureState memory expState){expState = _calcRiskExposure(sysState, true);(expState.stablecoinExposed, expState.protocolExposed) = isExposed(sysState.rebalanceThreshold,expState.stablecoinExposure,expState.protocolExposure,expState.curveExposure);}function getUnifiedAssets(address[N_COINS] calldata vaults)publicviewoverridereturns (uint256 unifiedTotalAssets, uint256[N_COINS] memory unifiedAssets){for (uint256 i = 0; i < N_COINS; i++) {uint256 assets = IVault(vaults[i]).totalAssets();unifiedAssets[i] = assets.mul(DEFAULT_DECIMALS_FACTOR).div(uint256(10)**IERC20Detailed(IVault(vaults[i]).token()).decimals());unifiedTotalAssets = unifiedTotalAssets.add(unifiedAssets[i]);}}function calcRoughDelta(uint256[N_COINS] calldata targets,address[N_COINS] calldata vaults,uint256 withdrawUsd) external view override returns (uint256[N_COINS] memory delta) {(uint256 totalAssets, uint256[N_COINS] memory vaultTotalAssets) = getUnifiedAssets(vaults);require(totalAssets > withdrawUsd, "totalAssets < withdrawalUsd");totalAssets = totalAssets.sub(withdrawUsd);uint256 totalDelta;for (uint256 i; i < N_COINS; i++) {uint256 target = totalAssets.mul(targets[i]).div(PERCENTAGE_DECIMAL_FACTOR);if (vaultTotalAssets[i] > target) {delta[i] = vaultTotalAssets[i].sub(target);totalDelta = totalDelta.add(delta[i]);}}uint256 percent = PERCENTAGE_DECIMAL_FACTOR;for (uint256 i; i < N_COINS - 1; i++) {if (delta[i] > 0) {delta[i] = delta[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(totalDelta);percent = percent.sub(delta[i]);}}delta[N_COINS - 1] = percent;return delta;}function sortVaultsByDelta(bool bigFirst,uint256 unifiedTotalAssets,uint256[N_COINS] calldata unifiedAssets,uint256[N_COINS] calldata targetPercents) external pure override returns (uint256[N_COINS] memory vaultIndexes) {uint256 maxIndex;uint256 minIndex;int256 maxDelta;int256 minDelta;for (uint256 i = 0; i < N_COINS; i++) {int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR));if (delta > maxDelta) {maxDelta = delta;maxIndex = i;} else if (delta < minDelta) {minDelta = delta;minIndex = i;}}if (bigFirst) {vaultIndexes[0] = maxIndex;vaultIndexes[2] = minIndex;} else {vaultIndexes[0] = minIndex;vaultIndexes[2] = maxIndex;}vaultIndexes[1] = N_COINS - maxIndex - minIndex;}function calculatePercentOfSystem(address vault,uint256 index,uint256 vaultAssetsPercent,uint256 vaultAssets) private view returns (uint256 percentOfSystem) {if (vaultAssets == 0) return 0;uint256 strategyAssetsPercent = IVault(vault).getStrategyAssets(index).mul(PERCENTAGE_DECIMAL_FACTOR).div(vaultAssets);percentOfSystem = vaultAssetsPercent.mul(strategyAssetsPercent).div(PERCENTAGE_DECIMAL_FACTOR);}function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure)privateviewreturns (uint256[N_COINS] memory stableCoinExposure){uint256 maker = directlyExposure[0].mul(makerUSDCExposure).div(PERCENTAGE_DECIMAL_FACTOR);for (uint256 i = 0; i < N_COINS; i++) {uint256 indirectExposure = curveExposure;if (i == 1) {indirectExposure = indirectExposure.add(maker);}stableCoinExposure[i] = directlyExposure[i].add(indirectExposure);}}function isExposed(uint256 rebalanceThreshold,uint256[N_COINS] memory stableCoinExposure,uint256[] memory protocolExposure,uint256 curveExposure) private pure returns (bool stablecoinExposed, bool protocolExposed) {for (uint256 i = 0; i < N_COINS; i++) {if (stableCoinExposure[i] > rebalanceThreshold) {stablecoinExposed = true;break;}}for (uint256 i = 0; i < protocolExposure.length; i++) {if (protocolExposure[i] > rebalanceThreshold) {protocolExposed = true;break;}}if (!protocolExposed && curveExposure > rebalanceThreshold) protocolExposed = true;return (stablecoinExposed, protocolExposed);}function _calcRiskExposure(SystemState memory sysState, bool treatLifeguardAsCurve)privateviewreturns (ExposureState memory expState){address[N_COINS] memory vaults = _controller().vaults();uint256 pCount = protocolCount;expState.protocolExposure = new uint256[](pCount);if (sysState.totalCurrentAssetsUsd == 0) {return expState;}for (uint256 i = 0; i < N_COINS; i++) {uint256 vaultAssetsPercent = sysState.vaultCurrentAssetsUsd[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(sysState.totalCurrentAssetsUsd);expState.stablecoinExposure[i] = vaultAssetsPercent;for (uint256 j = 0; j < pCount; j++) {uint256 percentOfSystem = calculatePercentOfSystem(vaults[i],j,vaultAssetsPercent,sysState.vaultCurrentAssets[i]);expState.protocolExposure[j] = expState.protocolExposure[j].add(percentOfSystem);}}if (treatLifeguardAsCurve) {expState.curveExposure = sysState.curveCurrentAssetsUsd.add(sysState.lifeguardCurrentAssetsUsd);} else {expState.curveExposure = sysState.curveCurrentAssetsUsd;}expState.curveExposure = expState.curveExposure.mul(PERCENTAGE_DECIMAL_FACTOR).div(sysState.totalCurrentAssetsUsd);expState.stablecoinExposure = calculateStableCoinExposure(expState.stablecoinExposure, expState.curveExposure);}}