pragma solidity 0.8.4;import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";import "./interfaces/pooltogether/IProtocolYieldSource.sol";import "./interfaces/idle/IIdleToken.sol";import "./access/AssetManager.sol";contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager {using SafeERC20Upgradeable for IERC20Upgradeable;address public idleToken;address public underlyingAsset;uint256 public constant ONE_IDLE_TOKEN = 10**18;event IdleYieldSourceInitialized(address indexed idleToken);event RedeemedToken(address indexed from,uint256 shares,uint256 amount);event SuppliedTokenTo(address indexed from,uint256 shares,uint256 amount,address indexed to);event Sponsored(address indexed from,uint256 amount);event TransferredERC20(address indexed from,address indexed to,uint256 amount,address indexed token);function initialize(address _idleToken) public initializer {__Ownable_init();idleToken = _idleToken;underlyingAsset = IIdleToken(idleToken).token();IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);emit IdleYieldSourceInitialized(idleToken);}function depositToken() external view override returns (address) {return underlyingAsset;}function balanceOfToken(address addr) external view override returns (uint256) {return _sharesToToken(balanceOf(addr));}function _totalShare() internal view returns(uint256) {return IIdleToken(idleToken).balanceOf(address(this));}function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {shares = (tokens * ONE_IDLE_TOKEN) / _price();}function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {tokens = (shares * _price()) / ONE_IDLE_TOKEN;}function _price() internal view returns (uint256) {return IIdleToken(idleToken).tokenPriceWithFee(address(this));}function _depositToIdle(uint256 mintAmount) internal returns (uint256) {IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);return IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));}function supplyTokenTo(uint256 mintAmount, address to) external nonReentrant override {uint256 mintedTokenShares = _tokenToShares(mintAmount);_depositToIdle(mintAmount);_mint(to, mintedTokenShares);emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);}function redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256 redeemedUnderlyingAsset) {uint256 redeemedShare = _tokenToShares(redeemAmount);_burn(msg.sender, redeemedShare);redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(redeemedShare);IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);emit RedeemedToken(msg.sender, redeemedShare, redeemAmount);}function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {require(erc20Token != idleToken, "IdleYieldSource/idleDai-transfer-not-allowed");IERC20Upgradeable(erc20Token).safeTransfer(to, amount);emit TransferredERC20(msg.sender, to, amount, erc20Token);}function sponsor(uint256 amount) external override {_depositToIdle(amount);emit Sponsored(msg.sender, amount);}}