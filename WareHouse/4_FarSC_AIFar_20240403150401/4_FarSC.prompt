pragma solidity ^0.8.0;contract TracerPerpetualsFactory is Ownable, ITracerPerpetualsFactory {uint256 public tracerCounter;address public perpsDeployer;address public liquidationDeployer;address public insuranceDeployer;address public pricingDeployer;mapping(uint256 => address) public override tracersByIndex;mapping(address => bool) public override validTracers;mapping(address => bool) public override daoApproved;event TracerDeployed(bytes32 indexed marketId, address indexed market);constructor(address _perpsDeployer,address _liquidationDeployer,address _insuranceDeployer,address _pricingDeployer,address _governance) {setPerpsDeployerContract(_perpsDeployer);setLiquidationDeployerContract(_liquidationDeployer);setInsuranceDeployerContract(_insuranceDeployer);setPricingDeployerContract(_pricingDeployer);transferOwnership(_governance);}function deployTracer(bytes calldata _data,address oracle,address fastGasOracle,uint256 maxLiquidationSlippage) external {_deployTracer(_data, msg.sender, oracle, fastGasOracle, maxLiquidationSlippage);}function deployTracerAndApprove(bytes calldata _data,address oracle,address fastGasOracle,uint256 maxLiquidationSlippage) external onlyOwner() {address tracer = _deployTracer(_data, owner(), oracle, fastGasOracle, maxLiquidationSlippage);setApproved(address(tracer), true);}function _deployTracer(bytes calldata _data,address tracerOwner,address oracle,address fastGasOracle,uint256 maxLiquidationSlippage) internal returns (address) {address market = IPerpsDeployer(perpsDeployer).deploy(_data);ITracerPerpetualSwaps tracer = ITracerPerpetualSwaps(market);validTracers[market] = true;tracersByIndex[tracerCounter] = market;tracerCounter++;address insurance = IInsuranceDeployer(insuranceDeployer).deploy(market);address pricing = IPricingDeployer(pricingDeployer).deploy(market, insurance, oracle);address liquidation = ILiquidationDeployer(liquidationDeployer).deploy(pricing,market,insurance,fastGasOracle,maxLiquidationSlippage);tracer.setInsuranceContract(insurance);tracer.setPricingContract(pricing);tracer.setLiquidationContract(liquidation);tracer.transferOwnership(tracerOwner);ILiquidation(liquidation).transferOwnership(tracerOwner);emit TracerDeployed(tracer.marketId(), address(tracer));return market;}function setPerpsDeployerContract(address newDeployer) public override onlyOwner() {require(newDeployer != address(0), "address(0) given");perpsDeployer = newDeployer;}function setInsuranceDeployerContract(address newInsuranceDeployer) public override onlyOwner() {require(newInsuranceDeployer != address(0), "address(0) given");insuranceDeployer = newInsuranceDeployer;}function setPricingDeployerContract(address newPricingDeployer) public override onlyOwner() {require(newPricingDeployer != address(0), "address(0) given");pricingDeployer = newPricingDeployer;}function setLiquidationDeployerContract(address newLiquidationDeployer) public override onlyOwner() {require(newLiquidationDeployer != address(0), "address(0) given");liquidationDeployer = newLiquidationDeployer;}function setApproved(address market, bool value) public override onlyOwner() {if (value) {require(Ownable(market).owner() == owner(), "TFC: Owner not DAO");}daoApproved[market] = value;}}