pragma solidity 0.6.12;contract SushiYieldSource is IYieldSource {using SafeMath for uint256;ISushiBar public immutable sushiBar;ISushi public immutable sushiAddr;mapping(address => uint256) public balances;constructor(ISushiBar _sushiBar, ISushi _sushiAddr) public {sushiBar = _sushiBar;sushiAddr = _sushiAddr;}function depositToken() public view override returns (address) {return address(sushiAddr);}function balanceOfToken(address addr) public override returns (uint256) {if (balances[addr] == 0) return 0;uint256 totalShares = sushiBar.totalSupply();uint256 barSushiBalance = sushiAddr.balanceOf(address(sushiBar));return balances[addr].mul(barSushiBalance).div(totalShares);}function supplyTokenTo(uint256 amount, address to) public override {sushiAddr.transferFrom(msg.sender, address(this), amount);sushiAddr.approve(address(sushiBar), amount);ISushiBar bar = sushiBar;uint256 beforeBalance = bar.balanceOf(address(this));bar.enter(amount);uint256 afterBalance = bar.balanceOf(address(this));uint256 balanceDiff = afterBalance.sub(beforeBalance);balances[to] = balances[to].add(balanceDiff);}function redeemToken(uint256 amount) public override returns (uint256) {ISushiBar bar = sushiBar;ISushi sushi = sushiAddr;uint256 totalShares = bar.totalSupply();if(totalShares == 0) return 0;uint256 barSushiBalance = sushi.balanceOf(address(bar));if(barSushiBalance == 0) return 0;uint256 sushiBeforeBalance = sushi.balanceOf(address(this));uint256 requiredShares = ((amount.mul(totalShares) + totalShares)).div(barSushiBalance);if(requiredShares == 0) return 0;uint256 requiredSharesBalance = requiredShares.sub(1);bar.leave(requiredSharesBalance);uint256 sushiAfterBalance = sushi.balanceOf(address(this));uint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);sushi.transfer(msg.sender, sushiBalanceDiff);return (sushiBalanceDiff);}}