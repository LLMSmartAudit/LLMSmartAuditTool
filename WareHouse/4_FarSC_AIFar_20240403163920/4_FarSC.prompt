pragma solidity 0.7.6; contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {using SafeMathUpgradeable for uint256;using SafeERC20Upgradeable for IERC20Upgradeable;event SwappableYieldSourceInitialized(IYieldSource indexed yieldSource,uint8 decimals,string symbol,string name,address indexed owner);event SwappableYieldSourceSet(IYieldSource indexed yieldSource);event FundsTransferred(IYieldSource indexed yieldSource,uint256 amount);event TransferredERC20(address indexed from,address indexed to,uint256 amount,IERC20Upgradeable indexed token);IYieldSource public yieldSource;function freeze() public initializer {}function _requireYieldSource(IYieldSource _yieldSource) internal view {require(address(_yieldSource) != address(0), "SwappableYieldSource/yieldSource-not-zero-address");(, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));bool isInvalidYieldSource;if (depositTokenAddressData.length > 0) {(address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));isInvalidYieldSource = depositTokenAddress != address(0);}require(isInvalidYieldSource, "SwappableYieldSource/invalid-yield-source");}function initialize(IYieldSource _yieldSource,uint8 _decimals,string calldata _symbol,string calldata _name,address _owner) public initializer returns (bool) {_requireYieldSource(_yieldSource);yieldSource = _yieldSource;__Ownable_init();require(_owner != address(0), "SwappableYieldSource/owner-not-zero-address");transferOwnership(_owner);__ReentrancyGuard_init();__ERC20_init(_name, _symbol);require(_decimals > 0, "SwappableYieldSource/decimals-gt-zero");_setupDecimals(_decimals);IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);emit SwappableYieldSourceInitialized(_yieldSource,_decimals,_symbol,_name,_owner);return true;}function approveMaxAmount() external onlyOwner returns (bool) {IYieldSource _yieldSource = yieldSource;IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));_depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));return true;}function _tokenToShares(uint256 tokens) internal returns (uint256) {uint256 shares;uint256 _totalSupply = totalSupply();if (_totalSupply == 0) {shares = tokens;} else {uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);}return shares;}function _sharesToToken(uint256 shares) internal returns (uint256) {uint256 tokens;uint256 _totalSupply = totalSupply();if (_totalSupply == 0) {tokens = shares;} else {uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);}return tokens;}function _mintShares(uint256 mintAmount, address to) internal {uint256 shares = _tokenToShares(mintAmount);require(shares > 0, "SwappableYieldSource/shares-gt-zero");_mint(to, shares);}function _burnShares(uint256 burnAmount) internal {uint256 shares = _tokenToShares(burnAmount);_burn(msg.sender, shares);}function supplyTokenTo(uint256 amount, address to) external override nonReentrant {IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());_depositToken.safeTransferFrom(msg.sender, address(this), amount);yieldSource.supplyTokenTo(amount, address(this));_mintShares(amount, to);}function depositToken() public view override returns (address) {return yieldSource.depositToken();}function balanceOfToken(address addr) external override returns (uint256) {return _sharesToToken(balanceOf(addr));}function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());_burnShares(amount);uint256 redeemableBalance = yieldSource.redeemToken(amount);_depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);return redeemableBalance;}function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {require(address(_yieldSource) != address(yieldSource), "SwappableYieldSource/same-yield-source");}function _setYieldSource(IYieldSource _newYieldSource) internal {_requireDifferentYieldSource(_newYieldSource);require(_newYieldSource.depositToken() == yieldSource.depositToken(), "SwappableYieldSource/different-deposit-token");yieldSource = _newYieldSource;IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);emit SwappableYieldSourceSet(_newYieldSource);}function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {_setYieldSource(_newYieldSource);return true;}function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {IYieldSource _currentYieldSource = yieldSource;_yieldSource.redeemToken(_amount);uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));require(_amount <= currentBalance, "SwappableYieldSource/transfer-amount-different");_currentYieldSource.supplyTokenTo(currentBalance, address(this));emit FundsTransferred(_yieldSource, _amount);}function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {_requireDifferentYieldSource(_yieldSource);_transferFunds(_yieldSource, amount);return true;}function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {IYieldSource _currentYieldSource = yieldSource;uint256 balance = _currentYieldSource.balanceOfToken(address(this));_setYieldSource(_newYieldSource);_transferFunds(_currentYieldSource, balance);return true;}function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {require(address(erc20Token) != address(yieldSource), "SwappableYieldSource/yield-source-token-transfer-not-allowed");erc20Token.safeTransfer(to, amount);emit TransferredERC20(msg.sender, to, amount, erc20Token);return true;}}