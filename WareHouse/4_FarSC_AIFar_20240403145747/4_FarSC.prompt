pragma solidity ^0.8.0;contract Pricing is IPricing {using LibMath for uint256;using LibMath for int256;using PRBMathSD59x18 for int256;address public tracer;IInsurance public insurance;IOracle public oracle;Prices.PriceInstant[24] internal hourlyTracerPrices;Prices.PriceInstant[24] internal hourlyOraclePrices;mapping(uint256 => Prices.FundingRateInstant) public fundingRates;mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;int256 public override timeValue;uint256 public override currentFundingIndex;uint256 public startLastHour;uint256 public startLast24Hours;uint8 public override currentHour;event HourlyPriceUpdated(uint256 price, uint256 currentHour);event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);constructor(address _tracer,address _insurance,address _oracle) {tracer = _tracer;insurance = IInsurance(_insurance);oracle = IOracle(_oracle);startLastHour = block.timestamp;startLast24Hours = block.timestamp;}function recordTrade(uint256 tradePrice) external override onlyTracer {uint256 currentOraclePrice = oracle.latestAnswer();if (startLastHour <= block.timestamp - 1 hours) {uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);updateFundingRate();if (startLast24Hours <= block.timestamp - 24 hours) {updateTimeValue();startLast24Hours = block.timestamp;}startLastHour = block.timestamp;if (currentHour == 23) {currentHour = 0;} else {currentHour = currentHour + 1;}updatePrice(tradePrice, currentOraclePrice, true);} else {updatePrice(tradePrice, currentOraclePrice, false);}}function updatePrice(uint256 marketPrice,uint256 oraclePrice,bool newRecord) internal {if (newRecord) {Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);hourlyTracerPrices[currentHour] = newHourly;Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);hourlyOraclePrices[currentHour] = oracleHour;} else {hourlyTracerPrices[currentHour].cumulativePrice =hourlyTracerPrices[currentHour].cumulativePrice +marketPrice;hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;hourlyOraclePrices[currentHour].cumulativePrice =hourlyOraclePrices[currentHour].cumulativePrice +oraclePrice;hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;}}function updateFundingRate() internal {ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);Prices.TWAP memory twapPrices = getTWAPs(currentHour);int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();uint256 underlyingTWAP = twapPrices.underlying;uint256 derivativeTWAP = twapPrices.derivative;int256 newFundingRate = PRBMathSD59x18.mul(derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,_tracer.fundingRateSensitivity().toInt256());int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;setFundingRate(newFundingRate, cumulativeFundingRate);emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);currentFundingIndex = currentFundingIndex + 1;}function fairPrice() external view override returns (uint256) {return Prices.fairPrice(oracle.latestAnswer(), timeValue);}function updateTimeValue() internal {(uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);}function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {fundingRates[currentFundingIndex] = Prices.FundingRateInstant(block.timestamp,fundingRate,cumulativeFundingRate);}function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(block.timestamp,fundingRate,cumulativeFundingRate);}function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {return fundingRates[index];}function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {return insuranceFundingRates[index];}function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);}function get24HourPrices() public view override returns (uint256, uint256) {return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));}function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {return Prices.averagePrice(hourlyTracerPrices[hour]);}function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {return Prices.averagePrice(hourlyOraclePrices[hour]);}modifier onlyTracer() {require(msg.sender == tracer, "PRC: Only Tracer");_;}}