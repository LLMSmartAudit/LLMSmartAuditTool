pragma solidity 0.8.3;import "./interfaces/iERC20.sol";import "./interfaces/iUTILS.sol";import "./interfaces/iUSDV.sol";import "./interfaces/iROUTER.sol";contract Vader is iERC20 {string public override name; string public override symbol;uint public override decimals; uint public override totalSupply;mapping(address => uint) private _balances;mapping(address => mapping(address => uint)) private _allowances;bool private inited;bool public emitting;bool public minting;uint _1m;uint public baseline;uint public emissionCurve;uint public maxSupply;uint public secondsPerEra;uint public currentEra;uint public nextEraTime;uint public feeOnTransfer;address public VETHER;address public USDV;address public UTILS;address public burnAddress;address public rewardAddress;address public DAO;event NewEra(uint currentEra, uint nextEraTime, uint emission);modifier onlyDAO() {require(msg.sender == DAO, "Not DAO");_;}modifier flashProof() {require(isMature(), "No flash");_;}function isMature() public view returns(bool){return iUSDV(USDV).isMature();}constructor() {name = 'VADER PROTOCOL TOKEN';symbol = 'VADER';decimals = 18;_1m = 10**6 * 10 ** decimals;baseline = _1m;totalSupply = 0;maxSupply = 2 * _1m;currentEra = 1;secondsPerEra = 1;nextEraTime = block.timestamp + secondsPerEra;emissionCurve = 900;DAO = msg.sender;burnAddress = 0x0111011001100001011011000111010101100101;}function init(address _vether, address _USDV, address _utils) external {require(inited == false);inited = true;VETHER = _vether;USDV = _USDV;UTILS = _utils;rewardAddress = _USDV;}function balanceOf(address account) external view override returns (uint) {return _balances[account];}function allowance(address owner, address spender) public view virtual override returns (uint) {return _allowances[owner][spender];}function transfer(address recipient, uint amount) external virtual override returns (bool) {_transfer(msg.sender, recipient, amount);return true;}function approve(address spender, uint amount) external virtual override returns (bool) {_approve(msg.sender, spender, amount);return true;}function _approve(address owner, address spender, uint amount) internal virtual {require(owner != address(0), "sender");require(spender != address(0), "spender");_allowances[owner][spender] = amount;emit Approval(owner, spender, amount);}function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {_transfer(sender, recipient, amount);_approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);return true;}function transferTo(address recipient, uint amount) external virtual override returns (bool) {_transfer(tx.origin, recipient, amount);return true;}function _transfer(address sender, address recipient, uint amount) internal virtual {require(sender != address(0), "sender");require(recipient != address(this), "recipient");_balances[sender] -= amount;uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);if(_fee >= 0 && _fee <= amount){amount -= _fee;_burn(msg.sender, _fee);}_balances[recipient] += amount;emit Transfer(sender, recipient, amount);_checkEmission();}function _mint(address account, uint amount) internal virtual {require(account != address(0), "recipient");if((totalSupply + amount) >= maxSupply){amount = maxSupply - totalSupply;}totalSupply += amount;_balances[account] += amount;emit Transfer(address(0), account, amount);}function burn(uint amount) public virtual override {_burn(msg.sender, amount);}function burnFrom(address account, uint amount) external virtual override {uint decreasedAllowance = allowance(account, msg.sender) - amount;_approve(account, msg.sender, decreasedAllowance);_burn(account, amount);}function _burn(address account, uint amount) internal virtual {require(account != address(0), "address err");_balances[account] -= amount;totalSupply -= amount;emit Transfer(account, address(0), amount);}function flipEmissions() external onlyDAO {if(emitting){emitting = false;} else {emitting = true;}}function flipMinting() external onlyDAO {if(minting){minting = false;} else {minting = true;}}function setParams(uint newEra, uint newCurve) external onlyDAO {secondsPerEra = newEra;emissionCurve = newCurve;}function setRewardAddress(address newAddress) external onlyDAO {rewardAddress = newAddress;}function changeUTILS(address newUTILS) external onlyDAO {require(newUTILS != address(0), "address err");UTILS = newUTILS;}function changeDAO(address newDAO) external onlyDAO {require(newDAO != address(0), "address err");DAO = newDAO;}function purgeDAO() external onlyDAO{DAO = address(0);}function _checkEmission() private {if ((block.timestamp >= nextEraTime) && emitting) {currentEra += 1;nextEraTime = block.timestamp + secondsPerEra;uint _emission = getDailyEmission();_mint(rewardAddress, _emission);feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);if(feeOnTransfer > 1000){feeOnTransfer = 1000;}emit NewEra(currentEra, nextEraTime, _emission);}}function getDailyEmission() public view returns (uint) {uint _adjustedMax;if(totalSupply <= baseline){_adjustedMax = (maxSupply * totalSupply) / baseline;} else {_adjustedMax = maxSupply;}return (_adjustedMax - totalSupply) / (emissionCurve);}function upgrade(uint amount) external {require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));_mint(msg.sender, amount);}function redeem() external returns (uint redeemAmount){return redeemToMember(msg.sender);}function redeemToMember(address member) public flashProof returns (uint redeemAmount){if(minting){uint _amount = iERC20(USDV).balanceOf(address(this));iERC20(USDV).burn(_amount);redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount);_mint(member, redeemAmount);}}}