pragma solidity ^0.8.10;import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";import {Context} from "@openzeppelin/contracts/utils/Context.sol";import {Counters} from "@openzeppelin/contracts/utils/Counters.sol";import {Address} from "@openzeppelin/contracts/utils/Address.sol";import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";import {Trust} from "@rari-capital/solmate/src/auth/Trust.sol";import {IVault} from "./vault/IVault.sol";import {IVaultSponsoring} from "./vault/IVaultSponsoring.sol";import {PercentMath} from "./lib/PercentMath.sol";import {Depositors} from "./vault/Depositors.sol";import {Claimers} from "./vault/Claimers.sol";import {IIntegration} from "./integrations/IIntegration.sol";import {IStrategy} from "./strategy/IStrategy.sol";import {ERC165Query} from "./lib/ERC165Query.sol";import "hardhat/console.sol";contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {using Counters for Counters.Counter;using SafeERC20 for IERC20;using PercentMath for uint256;using Address for address;using ERC165Query for address;uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in secondsuint256 public constant SHARES_MULTIPLIER = 10**18;IERC20 public override(IVault) underlying;IStrategy public strategy;uint256 public investPerc;uint256 public immutable override(IVault) minLockPeriod;uint256 public override(IVaultSponsoring) totalSponsored;Depositors public depositors;Claimers public claimers;Counters.Counter private _depositGroupIds;constructor(IERC20 _underlying,uint256 _minLockPeriod,uint256 _investPerc,address _owner) Trust(_owner) {require(PercentMath.validPerc(_investPerc),"Vault: invalid investPerc");require(address(_underlying) != address(0x0),"VaultContext: underlying cannot be 0x0");investPerc = _investPerc;underlying = _underlying;minLockPeriod = _minLockPeriod;depositors = new Depositors(address(this), "depositors", "p");claimers = new Claimers(address(this));}function setStrategy(address _strategy)externaloverride(IVault)requiresTrust{require(_strategy != address(0), "Vault: strategy 0x");require(IStrategy(_strategy).vault() == address(this),"Vault: invalid vault");require(address(strategy) == address(0) || strategy.investedAssets() == 0,"Vault: strategy has invested funds");strategy = IStrategy(_strategy);}function totalUnderlying() public view override(IVault) returns (uint256) {if (address(strategy) != address(0)) {returnunderlying.balanceOf(address(this)) + strategy.investedAssets();} else {return underlying.balanceOf(address(this));}}function totalShares() public view override(IVault) returns (uint256) {return claimers.totalShares();}function yieldFor(address _to)publicviewoverride(IVault)returns (uint256){uint256 tokenId = claimers.addressToTokenID(_to);uint256 claimerPrincipal = claimers.principalOf(tokenId);uint256 claimerShares = claimers.sharesOf(tokenId);uint256 currentClaimerPrincipal = _computeAmount(claimerShares,totalShares(),totalUnderlyingMinusSponsored());if (currentClaimerPrincipal <= claimerPrincipal) {return 0;}return currentClaimerPrincipal - claimerPrincipal;}function deposit(DepositParams calldata _params) external {_createDeposit(_params.amount, _params.lockedUntil, _params.claims);_transferAndCheckUnderlying(_msgSender(), _params.amount);}function claimYield(address _to) external override(IVault) {uint256 yield = yieldFor(_msgSender());if (yield == 0) return;uint256 shares = _computeShares(yield,totalShares(),totalUnderlyingMinusSponsored());uint256 sharesAmount = _computeAmount(shares,totalShares(),totalUnderlyingMinusSponsored());claimers.claimYield(_msgSender(), _to, sharesAmount, shares);underlying.safeTransfer(_to, sharesAmount);}function withdraw(address _to, uint256[] memory _ids)externaloverride(IVault){_withdraw(_to, _ids, false);}function forceWithdraw(address _to, uint256[] memory _ids) external {_withdraw(_to, _ids, true);}function setInvestPerc(uint16 _investPerc) external requiresTrust {require(PercentMath.validPerc(_investPerc),"Vault: invalid investPerc");emit InvestPercentageUpdated(_investPerc);investPerc = _investPerc;}function investableAmount() public view returns (uint256) {uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);uint256 alreadyInvested = strategy.investedAssets();if (alreadyInvested >= maxInvestableAssets) {return 0;} else {return maxInvestableAssets - alreadyInvested;}}function updateInvested() external requiresTrust {require(address(strategy) != address(0), "Vault: strategy is not set");uint256 _investable = investableAmount();if (_investable > 0) {underlying.safeTransfer(address(strategy), _investable);emit Invested(_investable);}strategy.doHardWork();}function sponsor(uint256 _amount, uint256 _lockedUntil)externaloverride(IVaultSponsoring){if (_lockedUntil == 0)_lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;elserequire(_lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,"Vault: lock time is too small");uint256 tokenId = depositors.mint(_msgSender(),_amount,0,_lockedUntil);emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);totalSponsored += _amount;_transferAndCheckUnderlying(_msgSender(), _amount);}function unsponsor(address _to, uint256[] memory _ids) external {_unsponsor(_to, _ids, false);}function forceUnsponsor(address _to, uint256[] memory _ids) external {_unsponsor(_to, _ids, true);}function totalUnderlyingMinusSponsored() public view returns (uint256) {return totalUnderlying() - totalSponsored;}function supportsInterface(bytes4 interfaceId)publicviewvirtualoverride(ERC165)returns (bool){returninterfaceId == type(IVault).interfaceId ||interfaceId == type(IVaultSponsoring).interfaceId ||super.supportsInterface(interfaceId);}function _withdraw(address _to,uint256[] memory _ids,bool _force) internal {uint256 localTotalShares = totalShares();uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();uint256 amount;for (uint8 i = 0; i < _ids.length; i++) {amount += _withdrawDeposit(_ids[i],localTotalShares,localTotalPrincipal,_to,_force);}underlying.safeTransfer(_to, amount);}function _unsponsor(address _to,uint256[] memory _ids,bool _force) internal {uint256 sponsorAmount;for (uint8 i = 0; i < _ids.length; i++) {uint256 tokenId = _ids[i];require(depositors.ownerOf(tokenId) == _msgSender(),"Vault: you are not the owner of a sponsor");(uint256 depositAmount,uint256 claimerId,uint256 lockedUntil) = depositors.deposits(tokenId);require(lockedUntil <= block.timestamp, "Vault: amount is locked");require(claimerId == 0, "Vault: token id is not a sponsor");depositors.burn(tokenId);emit Unsponsored(tokenId);sponsorAmount += depositAmount;}uint256 sponsorToTransfer = sponsorAmount;if (_force && sponsorAmount > totalUnderlying()) {sponsorToTransfer = totalUnderlying();} else if (!_force) {require(sponsorToTransfer <= totalUnderlying(),"Vault: not enough funds to unsponsor");}totalSponsored -= sponsorAmount;underlying.safeTransfer(_to, sponsorToTransfer);}function _createDeposit(uint256 _amount,uint256 _lockedUntil,ClaimParams[] calldata claims) internal {if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;elserequire(_lockedUntil >= block.timestamp + minLockPeriod,"Vault: lock time is too small");uint256 localTotalShares = totalShares();uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();uint256 pct = 0;for (uint256 i = 0; i < claims.length; ++i) {ClaimParams memory data = claims[i];_createClaim(_depositGroupIds.current(),_amount,_lockedUntil,data,localTotalShares,localTotalUnderlying);pct += data.pct;}_depositGroupIds.increment();require(pct.is100Perc(), "Vault: claims don't add up to 100%");}function _createClaim(uint256 _depositGroupId,uint256 _amount,uint256 _lockedUntil,ClaimParams memory _claim,uint256 _localTotalShares,uint256 _localTotalPrincipal) internal {uint256 amount = _amount.percOf(_claim.pct);uint256 newShares = _computeShares(amount,_localTotalShares,_localTotalPrincipal);uint256 claimerId = claimers.mint(_claim.beneficiary,amount,newShares);uint256 tokenId = depositors.mint(_msgSender(),amount,claimerId,_lockedUntil);if (_isIntegration(_claim.beneficiary)) {bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(tokenId,newShares,_claim.data);require(ret == IIntegration(_claim.beneficiary).onDepositMinted.selector);}emit DepositMinted(tokenId,_depositGroupId,amount,newShares,_msgSender(),_claim.beneficiary,claimerId,_lockedUntil);}function _withdrawDeposit(uint256 _tokenId,uint256 _totalShares,uint256 _totalUnderlyingMinusSponsored,address _to,bool _force) internal returns (uint256) {require(depositors.ownerOf(_tokenId) == _msgSender(),"Vault: you are not the owner of a deposit");(uint256 depositAmount,uint256 claimerId,uint256 lockedUntil) = depositors.deposits(_tokenId);require(lockedUntil <= block.timestamp, "Vault: deposit is locked");require(claimerId != 0, "Vault: token id is not a withdraw");uint256 claimerShares = claimers.sharesOf(claimerId);uint256 depositShares = _computeShares(depositAmount,_totalShares,_totalUnderlyingMinusSponsored);if (_force && depositShares > claimerShares) {depositShares = claimerShares;} else if (!_force) {require(claimerShares >= depositShares,"Vault: cannot withdraw more than the available amount");}claimers.onWithdraw(claimerId, depositAmount, depositShares);depositors.burn(_tokenId);address claimer = claimers.ownerOf(claimerId);if (_isIntegration(claimer)) {bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);require(ret == IIntegration(claimer).onDepositBurned.selector);}emit DepositBurned(_tokenId, depositShares, _to);return_computeAmount(depositShares,_totalShares,_totalUnderlyingMinusSponsored);}function _transferAndCheckUnderlying(address _from, uint256 _amount)internal{uint256 balanceBefore = totalUnderlying();underlying.safeTransferFrom(_from, address(this), _amount);uint256 balanceAfter = totalUnderlying();require(balanceAfter == balanceBefore + _amount,"Vault: amount received does not match params");}function _blockTimestamp() public view returns (uint64) {return uint64(block.timestamp);}function _computeShares(uint256 _amount,uint256 _totalShares,uint256 _totalUnderlyingMinusSponsored) internal pure returns (uint256) {if (_amount == 0) return 0;if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;require(_totalUnderlyingMinusSponsored > 0,"Vault: cannot compute shares when there's no principal");return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;}function _computeAmount(uint256 _shares,uint256 _totalShares,uint256 _totalUnderlyingMinusSponsored) internal pure returns (uint256) {if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {return 0;} else {return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);}}function _isIntegration(address addr) internal view returns (bool) {returnaddr.doesContractImplementInterface(type(IIntegration).interfaceId);}}