pragma solidity 0.6.8;import "../interface/IERC3156Upgradeable.sol";import "./ERC20Upgradeable.sol";import "../proxy/Initializable.sol";abstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLenderUpgradeable {function __ERC20FlashMint_init() internal initializer {__Context_init_unchained();__ERC20FlashMint_init_unchained();}function __ERC20FlashMint_init_unchained() internal initializer {}bytes32 constant private RETURN_VALUE = keccak256("ERC3156FlashBorrower.onFlashLoan");function maxFlashLoan(address token) public view override returns (uint256) {return token == address(this) ? type(uint256).max - ERC20Upgradeable.totalSupply() : 0;}function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {require(token == address(this), "ERC20FlashMint: wrong token");amount;return 0;}function flashLoan(IERC3156FlashBorrowerUpgradeable receiver,address token,uint256 amount,bytes memory data)public virtual override returns (bool){uint256 fee = flashFee(token, amount);_mint(address(receiver), amount);require(receiver.onFlashLoan(msg.sender, token, amount, fee, data) == RETURN_VALUE, "ERC20FlashMint: invalid return value");uint256 currentAllowance = allowance(address(receiver), address(this));require(currentAllowance >= amount + fee, "ERC20FlashMint: allowance does not allow refund");_approve(address(receiver), address(this), currentAllowance - amount - fee);_burn(address(receiver), amount + fee);return true;}uint256[50] private __gap;}