pragma solidity 0.8.4;import "@openzeppelin/contracts/proxy/utils/Initializable.sol";import "@openzeppelin/contracts/utils/math/SafeCast.sol";import "hardhat/console.sol";import "./interfaces/IRealitio.sol";import "./interfaces/IRCFactory.sol";import "./interfaces/IRCTreasury.sol";import "./interfaces/IRCMarket.sol";import "./interfaces/IRCNftHubL2.sol";import "./interfaces/IRCOrderbook.sol";import "./lib/NativeMetaTransaction.sol";contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {║      VARIABLES      ║╚═════════════════════════════════╝*/uint256 public numberOfCards;uint256 public constant MAX_UINT256 = type(uint256).max;uint256 public constant MIN_RENTAL_VALUE = 1 ether;States public override state;enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}Mode public mode;bool public constant override isMarket = true;uint256 public totalNftMintCount;IRCTreasury public treasury;IRCFactory public factory;IRCNftHubL2 public nfthub;IRCOrderbook public orderbook;mapping(uint256 => uint256) public cardPrice;mapping(address => uint256) public rentCollectedPerUser;mapping(uint256 => uint256) public rentCollectedPerCard;mapping(address => mapping(uint256 => uint256))public rentCollectedPerUserPerCard;uint256 public totalRentCollected;mapping(address => uint256) public exitedTimestamp;uint256 public minimumPriceIncreasePercent;uint256 public minRentalDayDivisor;uint256 public maxRentIterations;mapping(uint256 => mapping(address => uint256)) public timeHeld;mapping(uint256 => uint256) public totalTimeHeld;mapping(uint256 => uint256) public timeLastCollected;mapping(uint256 => uint256) public longestTimeHeld;mapping(uint256 => address) public longestOwner;mapping(uint256 => uint256) public cardTimeLimit;uint32 public marketOpeningTime;uint32 public override marketLockingTime;uint32 public oracleResolutionTime;uint256 public winningOutcome;mapping(address => bool) public userAlreadyWithdrawn;mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // booladdress public artistAddress;uint256 public artistCut;bool public artistPaid;address public affiliateAddress;uint256 public affiliateCut;bool public affiliatePaid;uint256 public winnerCut;address public marketCreatorAddress;uint256 public creatorCut;bool public creatorPaid;address[] public cardAffiliateAddresses;uint256 public cardAffiliateCut;mapping(uint256 => bool) public cardAffiliatePaid;bytes32 public questionId;bool public questionFinalised;address public arbitrator;uint32 public timeout;IRealitio public realitio;address public _realitioAddress;║       EVENTS       ║╚═════════════════════════════════╝*/event LogNewOwner(uint256 indexed cardId, address indexed newOwner);event LogRentCollection(uint256 rentCollected,uint256 indexed newTimeHeld,uint256 indexed cardId,address indexed owner);event LogContractLocked(bool indexed didTheEventFinish);event LogWinnerKnown(uint256 indexed winningOutcome);event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);event LogStakeholderPaid(address indexed paidTo,uint256 indexed amountPaid);event LogRentReturned(address indexed returnedTo,uint256 indexed amountReturned);event LogStateChange(uint256 indexed newState);event LogUpdateTimeHeldLimit(address indexed owner,uint256 newLimit,uint256 cardId);event LogSponsor(address indexed sponsor, uint256 indexed amount);event LogNftUpgraded(uint256 indexed currentTokenId,uint256 indexed newTokenId);event LogPayoutDetails(address indexed artistAddress,address marketCreatorAddress,address affiliateAddress,address[] cardAffiliateAddresses,uint256 indexed artistCut,uint256 winnerCut,uint256 creatorCut,uint256 affiliateCut,uint256 cardAffiliateCut);event LogSettings(uint256 indexed minRentalDayDivisor,uint256 indexed minimumPriceIncreasePercent);event LogLongestOwner(uint256 cardId, address longestOwner);event LogQuestionPostedToOracle(address indexed marketAddress,bytes32 indexed questionId);║      CONSTRUCTOR      ║╚═════════════════════════════════╝*/function initialize(uint256 _mode,uint32[] memory _timestamps,uint256 _numberOfCards,uint256 _totalNftMintCount,address _artistAddress,address _affiliateAddress,address[] memory _cardAffiliateAddresses,address _marketCreatorAddress,string calldata _realitioQuestion) external override initializer {assert(_mode <= 2);_initializeEIP712("RealityCardsMarket", "1");factory = IRCFactory(msgSender());treasury = factory.treasury();nfthub = factory.nfthub();orderbook = factory.orderbook();uint256[5] memory _potDistribution = factory.getPotDistribution();minRentalDayDivisor = treasury.minRentalDayDivisor();minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();maxRentIterations = factory.maxRentIterations();winningOutcome = MAX_UINT256; // default invalidmode = Mode(_mode);numberOfCards = _numberOfCards;totalNftMintCount = _totalNftMintCount;marketOpeningTime = _timestamps[0];marketLockingTime = _timestamps[1];oracleResolutionTime = _timestamps[2];artistAddress = _artistAddress;marketCreatorAddress = _marketCreatorAddress;affiliateAddress = _affiliateAddress;cardAffiliateAddresses = _cardAffiliateAddresses;artistCut = _potDistribution[0];winnerCut = _potDistribution[1];creatorCut = _potDistribution[2];affiliateCut = _potDistribution[3];cardAffiliateCut = _potDistribution[4];(realitio, arbitrator, timeout) = factory.getOracleSettings();if (_artistAddress == address(0)) {artistCut = 0;}if (_affiliateAddress == address(0)) {affiliateCut = 0;}if (_cardAffiliateAddresses.length == _numberOfCards) {for (uint256 i = 0; i < _numberOfCards; i++) {if (_cardAffiliateAddresses[i] == address(0)) {cardAffiliateCut = 0;}}} else {cardAffiliateCut = 0;}if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {winnerCut =(((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -cardAffiliateCut;}questionFinalised = false;_postQuestionToOracle(_realitioQuestion, _timestamps[2]);if (marketOpeningTime <= block.timestamp) {_incrementState();}emit LogPayoutDetails(_artistAddress,_marketCreatorAddress,_affiliateAddress,cardAffiliateAddresses,artistCut,winnerCut,creatorCut,affiliateCut,cardAffiliateCut);emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);}║      MODIFIERS      ║╚═════════════════════════════════╝*/modifier autoUnlock() {if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {_incrementState();}_;}modifier autoLock() {_;if (marketLockingTime <= block.timestamp) {lockMarket();}}modifier onlyTokenOwner(uint256 _token) {require(msgSender() == ownerOf(_token), "Not owner");_;}║   NFT HUB CONTRACT CALLS   ║╚═════════════════════════════════╝*/function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {_checkState(States.WITHDRAW);require(!factory.trapIfUnapproved() ||factory.isMarketApproved(address(this)),"Upgrade blocked");uint256 _tokenId = _card + totalNftMintCount;_transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting placenfthub.withdrawWithMetadata(_tokenId);emit LogNftUpgraded(_card, _tokenId);}function ownerOf(uint256 _cardId) public view override returns (address) {uint256 _tokenId = _cardId + totalNftMintCount;return nfthub.ownerOf(_tokenId);}function tokenURI(uint256 _cardId)publicviewoverridereturns (string memory){uint256 _tokenId = _cardId + totalNftMintCount;return nfthub.tokenURI(_tokenId);}function _transferCard(address _from,address _to,uint256 _cardId) internal {require(_from != address(0) && _to != address(0),"Cannot send to/from zero address");uint256 _tokenId = _cardId + totalNftMintCount;assert(nfthub.transferNft(_from, _to, _tokenId));emit LogNewOwner(_cardId, _to);}function transferCard(address _from,address _to,uint256 _cardId,uint256 _price,uint256 _timeLimit) external override {require(msgSender() == address(orderbook), "Not orderbook");_checkState(States.OPEN);if (_to != _from) {_transferCard(_from, _to, _cardId);}cardTimeLimit[_cardId] = _timeLimit;cardPrice[_cardId] = _price;}║    ORACLE FUNCTIONS     ║╚═════════════════════════════════╝*/function _postQuestionToOracle(string calldata _question,uint32 _oracleResolutionTime) internal {questionId = realitio.askQuestion(2,_question,arbitrator,timeout,_oracleResolutionTime,0);emit LogQuestionPostedToOracle(address(this), questionId);}function isFinalized() public view returns (bool) {bool _isFinalized = realitio.isFinalized(questionId);return _isFinalized;}function getWinnerFromOracle() external {require(isFinalized(), "Oracle not finalised");require(marketLockingTime <= block.timestamp, "Market not finished");questionFinalised = true;bytes32 _winningOutcome = realitio.resultFor(questionId);setWinner(uint256(_winningOutcome));}function setAmicableResolution(uint256 _winningOutcome) external {require(msgSender() == factory.owner(), "Not authorised");questionFinalised = true;setWinner(_winningOutcome);}║ MARKET RESOLUTION FUNCTIONS  ║╚═════════════════════════════════╝*/function lockMarket() public {_checkState(States.OPEN);require(marketLockingTime <= block.timestamp,"Market has not finished");if (collectRentAllCards()) {orderbook.closeMarket();_incrementState();for (uint256 i; i < numberOfCards; i++) {_transferCard(ownerOf(i), address(this), i);emit LogLongestOwner(i, longestOwner[i]);}emit LogContractLocked(true);}}function setWinner(uint256 _winningOutcome) internal {if (state == States.OPEN) {marketLockingTime = SafeCast.toUint32(block.timestamp);lockMarket();}if (state == States.LOCKED) {winningOutcome = _winningOutcome;_incrementState();emit LogWinnerKnown(winningOutcome);}}function withdraw() external {_checkState(States.WITHDRAW);require(!userAlreadyWithdrawn[msgSender()], "Already withdrawn");userAlreadyWithdrawn[msgSender()] = true;if (totalTimeHeld[winningOutcome] > 0) {_payoutWinnings();} else {_returnRent();}}function claimCard(uint256 _card) external {_checkNotState(States.CLOSED);_checkNotState(States.OPEN);require(!userAlreadyClaimed[_card][msgSender()], "Already claimed");userAlreadyClaimed[_card][msgSender()] = true;require(longestOwner[_card] == msgSender(), "Not longest owner");_transferCard(ownerOf(_card), longestOwner[_card], _card);}function _payoutWinnings() internal {uint256 _winningsToTransfer = 0;uint256 _remainingCut =((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -winnerCut) - creatorCut;if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {_winningsToTransfer = (totalRentCollected * winnerCut) / (1000);}uint256 _remainingPot = 0;if (mode == Mode.SAFE_MODE) {_remainingPot =((totalRentCollected - rentCollectedPerCard[winningOutcome]) *_remainingCut) /(1000);_winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][winningOutcome];} else {_remainingPot = (totalRentCollected * _remainingCut) / (1000);}uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];uint256 _numerator = _remainingPot * _winnersTimeHeld;_winningsToTransfer =_winningsToTransfer +(_numerator / totalTimeHeld[winningOutcome]);require(_winningsToTransfer > 0, "Not a winner");_payout(msgSender(), _winningsToTransfer);emit LogWinningsPaid(msgSender(), _winningsToTransfer);}function _returnRent() internal {uint256 _remainingCut =((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;uint256 _rentCollected = rentCollectedPerUser[msgSender()];require(_rentCollected > 0, "Paid no rent");uint256 _rentCollectedAdjusted =(_rentCollected * _remainingCut) / (1000);_payout(msgSender(), _rentCollectedAdjusted);emit LogRentReturned(msgSender(), _rentCollectedAdjusted);}function _payout(address _recipient, uint256 _amount) internal {assert(treasury.payout(_recipient, _amount));}function payArtist() external {_checkState(States.WITHDRAW);require(!artistPaid, "Artist already paid");artistPaid = true;_processStakeholderPayment(artistCut, artistAddress);}function payMarketCreator() external {_checkState(States.WITHDRAW);require(totalTimeHeld[winningOutcome] > 0, "No winner");require(!creatorPaid, "Creator already paid");creatorPaid = true;_processStakeholderPayment(creatorCut, marketCreatorAddress);}function payAffiliate() external {_checkState(States.WITHDRAW);require(!affiliatePaid, "Affiliate already paid");affiliatePaid = true;_processStakeholderPayment(affiliateCut, affiliateAddress);}function payCardAffiliate(uint256 _card) external {_checkState(States.WITHDRAW);require(!cardAffiliatePaid[_card], "Card affiliate already paid");cardAffiliatePaid[_card] = true;uint256 _cardAffiliatePayment =(rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);if (_cardAffiliatePayment > 0) {_payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);emit LogStakeholderPaid(cardAffiliateAddresses[_card],_cardAffiliatePayment);}}function _processStakeholderPayment(uint256 _cut, address _recipient)internal{if (_cut > 0) {uint256 _payment = (totalRentCollected * _cut) / (1000);_payout(_recipient, _payment);emit LogStakeholderPaid(_recipient, _payment);}}║     CORE FUNCTIONS     ║╠═════════════════════════════════╣║       EXTERNAL      ║╚═════════════════════════════════╝*/function collectRentAllCards() public override returns (bool) {_checkState(States.OPEN);bool _success = true;for (uint256 i = 0; i < numberOfCards; i++) {if (ownerOf(i) != address(this)) {_success = _collectRent(i);}if (!_success) {return false;}}return true;}function rentAllCards(uint256 _maxSumOfPrices) external {uint256 _actualSumOfPrices;for (uint256 i = 0; i < numberOfCards; i++) {_actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);}require(_actualSumOfPrices <= _maxSumOfPrices, "Prices too high");for (uint256 i = 0; i < numberOfCards; i++) {if (ownerOf(i) != msgSender()) {uint256 _newPrice;if (cardPrice[i] > 0) {_newPrice =(cardPrice[i] * (minimumPriceIncreasePercent + 100)) /100;} else {_newPrice = MIN_RENTAL_VALUE;}newRental(_newPrice, 0, address(0), i);}}}function newRental(uint256 _newPrice,uint256 _timeHeldLimit,address _startingPosition,uint256 _card) public autoUnlock() autoLock() {if (state == States.OPEN) {require(_newPrice >= MIN_RENTAL_VALUE, "Price below min");require(_card < numberOfCards, "Card does not exist");address _user = msgSender();require(exitedTimestamp[_user] != block.timestamp,"Cannot lose and re-rent in same block");require(!treasury.marketPaused(address(this)) &&!treasury.globalPause(),"Rentals are disabled");bool _userStillForeclosed = treasury.isForeclosed(_user);if (_userStillForeclosed) {_userStillForeclosed = orderbook.removeUserFromOrderbook(_user);}if (!_userStillForeclosed) {if (ownerOf(_card) == _user) {uint256 _requiredPrice =(cardPrice[_card] *(minimumPriceIncreasePercent + 100)) / (100);require(_newPrice >= _requiredPrice ||_newPrice < cardPrice[_card],"Invalid price");}orderbook.removeOldBids(_user);_collectRent(_card);uint256 _userTotalBidRate =treasury.userTotalBids(_user) -(orderbook.getBidValue(_user, _card)) +_newPrice;require(treasury.userDeposit(_user) >=_userTotalBidRate / minRentalDayDivisor,"Insufficient deposit");_timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);orderbook.addBidToOrderbook(_user,_card,_newPrice,_timeHeldLimit,_startingPosition);assert(treasury.updateLastRentalTime(_user));}}}function _checkTimeHeldLimit(uint256 _timeHeldLimit)internalviewreturns (uint256){if (_timeHeldLimit == 0) {return 0;} else {uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;require(_timeHeldLimit >= _minRentalTime, "Limit too low");return _timeHeldLimit;}}function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)external{_checkState(States.OPEN);address _user = msgSender();if (_collectRent(_card)) {_timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);if (ownerOf(_card) == _user) {cardTimeLimit[_card] = _timeHeldLimit;}emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);}}function exitAll() external override {for (uint256 i = 0; i < numberOfCards; i++) {exit(i);}}function exit(uint256 _card) public override {_checkState(States.OPEN);address _msgSender = msgSender();exitedTimestamp[_msgSender] = block.timestamp;_collectRent(_card);if (ownerOf(_card) == _msgSender) {orderbook.findNewOwner(_card, block.timestamp);assert(!orderbook.bidExists(_msgSender, address(this), _card));} else {if (orderbook.bidExists(_msgSender, address(this), _card)) {orderbook.removeBidFromOrderbook(_msgSender, _card);}}}function sponsor(uint256 _amount) external override {address _creator = msgSender();treasury.checkSponsorship(_creator, _amount);_sponsor(_creator, _amount);}function sponsor(address _sponsorAddress, uint256 _amount)externaloverride{_sponsor(_sponsorAddress, _amount);}function _sponsor(address _sponsorAddress, uint256 _amount) internal {_checkNotState(States.LOCKED);_checkNotState(States.WITHDRAW);require(_amount > 0, "Must send something");require(treasury.sponsor(_sponsorAddress, _amount));totalRentCollected = totalRentCollected + _amount;rentCollectedPerUser[_sponsorAddress] =rentCollectedPerUser[_sponsorAddress] +_amount;for (uint256 i = 0; i < numberOfCards; i++) {rentCollectedPerCard[i] =rentCollectedPerCard[i] +(_amount / numberOfCards);}emit LogSponsor(_sponsorAddress, _amount);}║     CORE FUNCTIONS     ║╠═════════════════════════════════╣║       INTERNAL      ║╚═════════════════════════════════╝*/function _collectRentAction(uint256 _card)internalreturns (bool shouldContinue){address _user = ownerOf(_card);uint256 _timeOfThisCollection = block.timestamp;if (marketLockingTime <= block.timestamp) {_timeOfThisCollection = marketLockingTime;}if (_user != address(this) &&timeLastCollected[_card] < _timeOfThisCollection) {uint256 _timeUserForeclosed =treasury.collectRentUser(_user, block.timestamp);uint256 _cardTimeLimitTimestamp =timeLastCollected[_card] + cardTimeLimit[_card];bool _foreclosed = _timeUserForeclosed != 0;bool _limitHit =cardTimeLimit[_card] != 0 &&_cardTimeLimitTimestamp < block.timestamp;bool _marketLocked = marketLockingTime <= block.timestamp;bool _newOwner;uint256 _refundTime; // seconds of rent to refund the user┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐│Case    │1│2│3│4│5│6│7│8│├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤│Foreclosure│0│0│0│0│1│1│1│1││Time Limit │0│0│1│1│0│0│1│1││Market Lock│0│1│0│1│0│1│0│1│└───────────┴─┴─┴─┴─┴─┴─┴─┴─┘if (!_foreclosed && !_limitHit && !_marketLocked) {_timeOfThisCollection = _timeOfThisCollection;_newOwner = false;_refundTime = 0;} else if (!_foreclosed && !_limitHit && _marketLocked) {_timeOfThisCollection = marketLockingTime;_newOwner = false;_refundTime = block.timestamp - marketLockingTime;} else if (!_foreclosed && _limitHit && !_marketLocked) {_timeOfThisCollection = _cardTimeLimitTimestamp;_newOwner = true;_refundTime = block.timestamp - _cardTimeLimitTimestamp;} else if (!_foreclosed && _limitHit && _marketLocked) {if (_cardTimeLimitTimestamp < marketLockingTime) {_timeOfThisCollection = _cardTimeLimitTimestamp;_newOwner = true;_refundTime = block.timestamp - _cardTimeLimitTimestamp;} else {_timeOfThisCollection = marketLockingTime;_newOwner = false;_refundTime = block.timestamp - marketLockingTime;}} else if (_foreclosed && !_limitHit && !_marketLocked) {_timeOfThisCollection = _timeUserForeclosed;_newOwner = true;_refundTime = 0;} else if (_foreclosed && !_limitHit && _marketLocked) {if (_timeUserForeclosed < marketLockingTime) {_timeOfThisCollection = _timeUserForeclosed;_newOwner = true;_refundTime = 0;} else {_timeOfThisCollection = marketLockingTime;_newOwner = false;_refundTime = block.timestamp - marketLockingTime;}} else if (_foreclosed && _limitHit && !_marketLocked) {if (_timeUserForeclosed < _cardTimeLimitTimestamp) {_timeOfThisCollection = _timeUserForeclosed;_newOwner = true;_refundTime = 0;} else {_timeOfThisCollection = _cardTimeLimitTimestamp;_newOwner = true;_refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;}} else {if (_timeUserForeclosed <= _cardTimeLimitTimestamp &&_timeUserForeclosed < marketLockingTime) {_timeOfThisCollection = _timeUserForeclosed;_newOwner = true;_refundTime = 0;} else if (_cardTimeLimitTimestamp < _timeUserForeclosed &&_cardTimeLimitTimestamp < marketLockingTime) {_timeOfThisCollection = _cardTimeLimitTimestamp;_newOwner = true;_refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;} else {_timeOfThisCollection = marketLockingTime;_newOwner = false;_refundTime = _timeUserForeclosed - marketLockingTime;}}if (_refundTime != 0) {uint256 _refundAmount =(_refundTime * cardPrice[_card]) / 1 days;treasury.refundUser(_user, _refundAmount);}_processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happensif (_newOwner) {orderbook.findNewOwner(_card, _timeOfThisCollection);return true;}} else {timeLastCollected[_card] = _timeOfThisCollection;}return false;}function _collectRent(uint256 _card)internalreturns (bool didUpdateEverything){uint32 counter = 0;bool shouldContinue = true;while (counter < maxRentIterations && shouldContinue) {shouldContinue = _collectRentAction(_card);counter++;}return !shouldContinue;}function _processRentCollection(address _user,uint256 _card,uint256 _timeOfCollection) internal {uint256 _rentOwed =(cardPrice[_card] *(_timeOfCollection - timeLastCollected[_card])) / 1 days;treasury.payRent(_rentOwed);uint256 _timeHeldToIncrement =(_timeOfCollection - timeLastCollected[_card]);if (cardTimeLimit[_card] != 0) {orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);cardTimeLimit[_card] -= _timeHeldToIncrement;}timeHeld[_card][_user] += _timeHeldToIncrement;totalTimeHeld[_card] += _timeHeldToIncrement;rentCollectedPerUser[_user] += _rentOwed;rentCollectedPerCard[_card] += _rentOwed;rentCollectedPerUserPerCard[_user][_card] += _rentOwed;totalRentCollected += _rentOwed;timeLastCollected[_card] = _timeOfCollection;if (timeHeld[_card][_user] > longestTimeHeld[_card]) {longestTimeHeld[_card] = timeHeld[_card][_user];longestOwner[_card] = _user;}emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);}function _checkState(States currentState) internal view {require(state == currentState, "Incorrect state");}function _checkNotState(States currentState) internal view {require(state != currentState, "Incorrect state");}function _incrementState() internal {assert(uint256(state) < 4);state = States(uint256(state) + (1));emit LogStateChange(uint256(state));}║    CIRCUIT BREAKER     ║╚═════════════════════════════════╝*/function circuitBreaker() external {require(block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),"Too early");_incrementState();orderbook.closeMarket();state = States.WITHDRAW;}▲▲ ▲}