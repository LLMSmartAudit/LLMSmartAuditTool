pragma solidity 0.8.3;import "./interfaces/iVETHER.sol";contract Vether is iVETHER {string public override name;                     // Name of Coinstring public override symbol;                    // Symbol of Coinuint public override decimals = 18;               // Decimalsuint public override totalSupply = 1*10**6 * (10 ** decimals);  // 1,000,000 Totaluint public totalFees;mapping(address=>bool) public mapAddress_Excluded;mapping(address => uint) private _balances;mapping(address => mapping(address => uint)) private _allowances;constructor() {name = "Vether";symbol = "VETH";_balances[msg.sender] = totalSupply;emit Transfer(address(0), msg.sender, totalSupply);}function balanceOf(address account) public view override returns (uint) {return _balances[account];}function allowance(address owner, address spender) public view virtual override returns (uint) {return _allowances[owner][spender];}function transfer(address recipient, uint amount) public virtual override returns (bool) {_transfer(msg.sender, recipient, amount);return true;}function approve(address spender, uint amount) public virtual override returns (bool) {_approve(msg.sender, spender, amount);return true;}function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {_approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);return true;}function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {_approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);return true;}function _approve(address owner, address spender, uint amount) internal virtual {require(owner != address(0), "iERC20: approve from the zero address");require(spender != address(0), "iERC20: approve to the zero address");_allowances[owner][spender] = amount;emit Approval(owner, spender, amount);}function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {_transfer(sender, recipient, amount);_approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);return true;}function _transfer(address _from, address _to, uint _value) private {require(_balances[_from] >= _value, 'Must not send more than balance');require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');_balances[_from] -= _value;uint _fee = _getFee(_from, _to, _value);                      // Get fee amount_balances[_to] += (_value - _fee);                        // Add to receiver_balances[address(this)] += _fee;                          // Add fee to selftotalFees += _fee;                                 // Track fees collectedemit Transfer(_from, _to, (_value - _fee));                   // Transfer eventif (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {emit Transfer(_from, address(this), _fee);                   // Fee Transfer event}}function _getFee(address _from, address _to, uint _value) private view returns (uint) {if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {return 0;                                    // No fee if excluded} else {return (_value / 1000);                             // Fee amount = 0.1%}}function addExcluded(address excluded) public {mapAddress_Excluded[excluded] = true;}}