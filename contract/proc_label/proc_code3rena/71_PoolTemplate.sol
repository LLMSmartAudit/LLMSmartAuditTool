pragma solidity 0.8.7;import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";import "./InsureDAOERC20.sol";import "./interfaces/IPoolTemplate.sol";import "./interfaces/IUniversalMarket.sol";import "./interfaces/IParameters.sol";import "./interfaces/IVault.sol";import "./interfaces/IRegistry.sol";import "./interfaces/IIndexTemplate.sol";contract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {event Deposit(address indexed depositor, uint256 amount, uint256 mint);event WithdrawRequested(address indexed withdrawer,uint256 amount,uint256 time);event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);event Unlocked(uint256 indexed id, uint256 amount);event Insured(uint256 indexed id,uint256 amount,bytes32 target,uint256 startTime,uint256 endTime,address insured,uint256 premium);event Redeemed(uint256 indexed id,address insured,bytes32 target,uint256 amount,uint256 payout);event CoverApplied(uint256 pending,uint256 payoutNumerator,uint256 payoutDenominator,uint256 incidentTimestamp,bytes32 merkleRoot,string rawdata,string memo);event TransferInsurance(uint256 indexed id, address from, address to);event CreditIncrease(address indexed depositor, uint256 credit);event CreditDecrease(address indexed withdrawer, uint256 credit);event MarketStatusChanged(MarketStatus statusValue);event Paused(bool paused);event MetadataChanged(string metadata);bool public initialized;bool public override paused;string public metadata;IParameters public parameters;IRegistry public registry;IVault public vault;uint256 public attributionDebt; //pool's attribution for indicesuint256 public override lockedAmount; //Liquidity locked when utilizeduint256 public override totalCredit; //Liquidity from indexuint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.uint256 public pendingEnd; //pending time when paying outstruct IndexInfo {uint256 credit; //How many credit (equal to liquidity) the index has allocateduint256 rewardDebt; // Reward debt. *See explanation below.bool exist; //true if the index has allocated credit}mapping(address => IndexInfo) public indicies;address[] public indexList;enum MarketStatus {Trading,Payingout}MarketStatus public marketStatus;struct Withdrawal {uint256 timestamp;uint256 amount;}mapping(address => Withdrawal) public withdrawalReq;struct Insurance {uint256 id; //each insuance has their own iduint256 startTime; //timestamp of starttimeuint256 endTime; //timestamp of endtimeuint256 amount; //insured amountbytes32 target; //target id in bytes32address insured; //the address holds the right to get insuredbool status; //true if insurance is not expired or redeemed}mapping(uint256 => Insurance) public insurances;uint256 public allInsuranceCount;struct Incident {uint256 payoutNumerator;uint256 payoutDenominator;uint256 incidentTimestamp;bytes32 merkleRoot;}Incident public incident;uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncationmodifier onlyOwner() {require(msg.sender == parameters.getOwner(),"Restricted: caller is not allowed to operate");_;}constructor() {initialized = true;}function initialize(string calldata _metaData,uint256[] calldata _conditions,address[] calldata _references) external override {require(initialized == false &&bytes(_metaData).length > 0 &&_references[0] != address(0) &&_references[1] != address(0) &&_references[2] != address(0) &&_references[3] != address(0) &&_references[4] != address(0) &&_conditions[0] <= _conditions[1],"ERROR: INITIALIZATION_BAD_CONDITIONS");initialized = true;string memory _name = string(abi.encodePacked("InsureDAO-",IERC20Metadata(_references[1]).name(),"-PoolInsurance"));string memory _symbol = string(abi.encodePacked("i-", IERC20Metadata(_references[1]).symbol()));uint8 _decimals = IERC20Metadata(_references[0]).decimals();initializeToken(_name, _symbol, _decimals);registry = IRegistry(_references[2]);parameters = IParameters(_references[3]);vault = IVault(parameters.getVault(_references[1]));metadata = _metaData;marketStatus = MarketStatus.Trading;if (_conditions[1] > 0) {_depositFrom(_conditions[1], _references[4]);}}function deposit(uint256 _amount) public returns (uint256 _mintAmount) {require(marketStatus == MarketStatus.Trading && paused == false,"ERROR: DEPOSIT_DISABLED");require(_amount > 0, "ERROR: DEPOSIT_ZERO");_mintAmount = worth(_amount);vault.addValue(_amount, msg.sender, address(this));emit Deposit(msg.sender, _amount, _mintAmount);_mint(msg.sender, _mintAmount);}function _depositFrom(uint256 _amount, address _from)internalreturns (uint256 _mintAmount){require(marketStatus == MarketStatus.Trading && paused == false,"ERROR: DEPOSIT_DISABLED");require(_amount > 0, "ERROR: DEPOSIT_ZERO");_mintAmount = worth(_amount);vault.addValue(_amount, _from, address(this));emit Deposit(_from, _amount, _mintAmount);_mint(_from, _mintAmount);}function requestWithdraw(uint256 _amount) external {uint256 _balance = balanceOf(msg.sender);require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE");require(_amount > 0, "ERROR: REQUEST_ZERO");withdrawalReq[msg.sender].timestamp = block.timestamp;withdrawalReq[msg.sender].amount = _amount;emit WithdrawRequested(msg.sender, _amount, block.timestamp);}function withdraw(uint256 _amount) external returns (uint256 _retVal) {uint256 _supply = totalSupply();require(_supply != 0, "ERROR: NO_AVAILABLE_LIQUIDITY");uint256 _liquidity = originalLiquidity();_retVal = (_amount * _liquidity) / _supply;require(marketStatus == MarketStatus.Trading,"ERROR: WITHDRAWAL_PENDING");require(withdrawalReq[msg.sender].timestamp +parameters.getLockup(msg.sender) <block.timestamp,"ERROR: WITHDRAWAL_QUEUE");require(withdrawalReq[msg.sender].timestamp +parameters.getLockup(msg.sender) +parameters.getWithdrawable(msg.sender) >block.timestamp,"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST");require(withdrawalReq[msg.sender].amount >= _amount,"ERROR: WITHDRAWAL_EXCEEDED_REQUEST");require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");require(_retVal <= availableBalance(),"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY");withdrawalReq[msg.sender].amount -= _amount;_burn(msg.sender, _amount);vault.withdrawValue(_retVal, msg.sender);emit Withdraw(msg.sender, _amount, _retVal);}function unlockBatch(uint256[] calldata _ids) external {for (uint256 i = 0; i < _ids.length; i++) {unlock(_ids[i]);}}function unlock(uint256 _id) public {require(insurances[_id].status == true &&marketStatus == MarketStatus.Trading &&insurances[_id].endTime + parameters.getGrace(msg.sender) <block.timestamp,"ERROR: UNLOCK_BAD_COINDITIONS");insurances[_id].status == false;lockedAmount = lockedAmount - insurances[_id].amount;emit Unlocked(_id, insurances[_id].amount);}function allocateCredit(uint256 _credit)externaloverridereturns (uint256 _pending){require(IRegistry(registry).isListed(msg.sender),"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS");IndexInfo storage _index = indicies[msg.sender];uint256 _rewardPerCredit = rewardPerCredit;if (_index.exist == false) {_index.exist = true;indexList.push(msg.sender);} else if (_index.credit > 0) {_pending = _sub((_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,_index.rewardDebt);if (_pending > 0) {vault.transferAttribution(_pending, msg.sender);attributionDebt -= _pending;}}if (_credit > 0) {totalCredit += _credit;_index.credit += _credit;emit CreditIncrease(msg.sender, _credit);}_index.rewardDebt =(_index.credit * _rewardPerCredit) /MAGIC_SCALE_1E6;}function withdrawCredit(uint256 _credit)externaloverridereturns (uint256 _pending){IndexInfo storage _index = indicies[msg.sender];uint256 _rewardPerCredit = rewardPerCredit;require(IRegistry(registry).isListed(msg.sender) &&_index.credit >= _credit &&_credit <= availableBalance(),"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS");_pending = _sub((_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,_index.rewardDebt);if (_credit > 0) {totalCredit -= _credit;_index.credit -= _credit;emit CreditDecrease(msg.sender, _credit);}if (_pending > 0) {vault.transferAttribution(_pending, msg.sender);attributionDebt -= _pending;_index.rewardDebt =(_index.credit * _rewardPerCredit) /MAGIC_SCALE_1E6;}}function insure(uint256 _amount,uint256 _maxCost,uint256 _span,bytes32 _target) external returns (uint256) {uint256 _endTime = _span + block.timestamp;uint256 _premium = getPremium(_amount, _span);uint256 _fee = parameters.getFeeRate(msg.sender);require(_amount <= availableBalance(),"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE");require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");require(parameters.getMinDate(msg.sender) <= _span,"ERROR: INSURE_SPAN_BELOW_MIN");require(marketStatus == MarketStatus.Trading,"ERROR: INSURE_MARKET_PENDING");require(paused == false, "ERROR: INSURE_MARKET_PAUSED");uint256 _liquidity = totalLiquidity();uint256 _totalCredit = totalCredit;uint256[2] memory _newAttribution = vault.addValueBatch(_premium,msg.sender,[address(this), parameters.getOwner()],[MAGIC_SCALE_1E6 - _fee, _fee]);uint256 _id = allInsuranceCount;lockedAmount += _amount;Insurance memory _insurance = Insurance(_id,block.timestamp,_endTime,_amount,_target,msg.sender,true);insurances[_id] = _insurance;allInsuranceCount += 1;if (_totalCredit > 0) {uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /_liquidity;attributionDebt += _attributionForIndex;rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /_totalCredit);}emit Insured(_id,_amount,_target,block.timestamp,_endTime,msg.sender,_premium);return _id;}function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {Insurance storage _insurance = insurances[_id];require(_insurance.status == true, "ERROR: INSURANCE_NOT_ACTIVE");uint256 _payoutNumerator = incident.payoutNumerator;uint256 _payoutDenominator = incident.payoutDenominator;uint256 _incidentTimestamp = incident.incidentTimestamp;bytes32 _targets = incident.merkleRoot;require(marketStatus == MarketStatus.Payingout,"ERROR: NO_APPLICABLE_INCIDENT");require(_insurance.insured == msg.sender, "ERROR: NOT_YOUR_INSURANCE");require(marketStatus == MarketStatus.Payingout &&_insurance.startTime <= _incidentTimestamp &&_insurance.endTime >= _incidentTimestamp,"ERROR: INSURANCE_NOT_APPLICABLE");require(MerkleProof.verify(_merkleProof,_targets,keccak256(abi.encodePacked(_insurance.target, _insurance.insured))) ||MerkleProof.verify(_merkleProof,_targets,keccak256(abi.encodePacked(_insurance.target, address(0)))),"ERROR: INSURANCE_EXEMPTED");_insurance.status = false;lockedAmount -= _insurance.amount;uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /_payoutDenominator;vault.borrowValue(_payoutAmount, msg.sender);emit Redeemed(_id,msg.sender,_insurance.target,_insurance.amount,_payoutAmount);}function transferInsurance(uint256 _id, address _to) external {Insurance storage insurance = insurances[_id];require(_to != address(0) &&insurance.insured == msg.sender &&insurance.endTime >= block.timestamp &&insurance.status == true,"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS");insurance.insured = _to;emit TransferInsurance(_id, msg.sender, _to);}function getPremium(uint256 _amount, uint256 _span)publicviewreturns (uint256 premium){returnparameters.getPremium(_amount,_span,totalLiquidity(),lockedAmount,address(this));}function applyCover(uint256 _pending,uint256 _payoutNumerator,uint256 _payoutDenominator,uint256 _incidentTimestamp,bytes32 _merkleRoot,string calldata _rawdata,string calldata _memo) external override onlyOwner {require(paused == false, "ERROR: UNABLE_TO_APPLY");incident.payoutNumerator = _payoutNumerator;incident.payoutDenominator = _payoutDenominator;incident.incidentTimestamp = _incidentTimestamp;incident.merkleRoot = _merkleRoot;marketStatus = MarketStatus.Payingout;pendingEnd = block.timestamp + _pending;for (uint256 i = 0; i < indexList.length; i++) {if (indicies[indexList[i]].credit > 0) {IIndexTemplate(indexList[i]).lock();}}emit CoverApplied(_pending,_payoutNumerator,_payoutDenominator,_incidentTimestamp,_merkleRoot,_rawdata,_memo);emit MarketStatusChanged(marketStatus);}function resume() external {require(marketStatus == MarketStatus.Payingout &&pendingEnd < block.timestamp,"ERROR: UNABLE_TO_RESUME");uint256 _debt = vault.debts(address(this));uint256 _totalCredit = totalCredit;uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /totalLiquidity();uint256 _actualDeduction;for (uint256 i = 0; i < indexList.length; i++) {address _index = indexList[i];uint256 _credit = indicies[_index].credit;if (_credit > 0) {uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /_totalCredit;uint256 _redeemAmount = _divCeil(_deductionFromIndex,_shareOfIndex);_actualDeduction += IIndexTemplate(_index).compensate(_redeemAmount);}}uint256 _deductionFromPool = _debt -_deductionFromIndex /MAGIC_SCALE_1E6;uint256 _shortage = _deductionFromIndex /MAGIC_SCALE_1E6 -_actualDeduction;if (_deductionFromPool > 0) {vault.offsetDebt(_deductionFromPool, address(this));}vault.transferDebt(_shortage);marketStatus = MarketStatus.Trading;emit MarketStatusChanged(MarketStatus.Trading);}function rate() external view returns (uint256) {if (totalSupply() > 0) {return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();} else {return 0;}}function valueOfUnderlying(address _owner)publicviewoverridereturns (uint256){uint256 _balance = balanceOf(_owner);if (_balance == 0) {return 0;} else {return (_balance * originalLiquidity()) / totalSupply();}}function pendingPremium(address _index)externalviewoverridereturns (uint256){uint256 _credit = indicies[_index].credit;if (_credit == 0) {return 0;} else {return_sub((_credit * rewardPerCredit) / MAGIC_SCALE_1E6,indicies[_index].rewardDebt);}}function worth(uint256 _value) public view returns (uint256 _amount) {uint256 _supply = totalSupply();uint256 _originalLiquidity = originalLiquidity();if (_supply > 0 && _originalLiquidity > 0) {_amount = (_value * _supply) / _originalLiquidity;} else if (_supply > 0 && _originalLiquidity == 0) {_amount = _value * _supply;} else {_amount = _value;}}function allocatedCredit(address _index)publicviewoverridereturns (uint256){return indicies[_index].credit;}function availableBalance()publicviewoverridereturns (uint256 _balance){if (totalLiquidity() > 0) {return totalLiquidity() - lockedAmount;} else {return 0;}}function utilizationRate() public view override returns (uint256 _rate) {if (lockedAmount > 0) {return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();} else {return 0;}}function totalLiquidity() public view override returns (uint256 _balance) {return originalLiquidity() + totalCredit;}function originalLiquidity() public view returns (uint256 _balance) {returnvault.underlyingValue(address(this)) -vault.attributionValue(attributionDebt);}function setPaused(bool _state) external override onlyOwner {if (paused != _state) {paused = _state;emit Paused(_state);}}function changeMetadata(string calldata _metadata)externaloverrideonlyOwner{metadata = _metadata;emit MetadataChanged(_metadata);}function _beforeTokenTransfer(address from,address to,uint256 amount) internal virtual override {super._beforeTokenTransfer(from, to, amount);if (from != address(0)) {uint256 _after = balanceOf(from) - amount;if (_after < withdrawalReq[from].amount) {withdrawalReq[from].amount = _after;}}}function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {require(b > 0);uint256 c = a / b;if (a % b != 0) c = c + 1;return c;}function _sub(uint256 a, uint256 b) internal pure returns (uint256) {if (a < b) {return 0;} else {return a - b;}}}