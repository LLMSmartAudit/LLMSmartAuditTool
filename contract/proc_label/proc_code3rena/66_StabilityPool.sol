pragma solidity 0.6.11;import "./Interfaces/IBorrowerOperations.sol";import "./Interfaces/IStabilityPool.sol";import "./Interfaces/IBorrowerOperations.sol";import "./Interfaces/ITroveManager.sol";import "./Interfaces/IYUSDToken.sol";import "./Interfaces/ISortedTroves.sol";import "./Interfaces/ICommunityIssuance.sol";import "./Interfaces/IWhitelist.sol";import "./Interfaces/IERC20.sol";import "./Interfaces/IWAsset.sol";import "./Dependencies/LiquityBase.sol";import "./Dependencies/SafeMath.sol";import "./Dependencies/LiquitySafeMath128.sol";import "./Dependencies/Ownable.sol";import "./Dependencies/CheckContract.sol";import "./Dependencies/SafeERC20.sol";contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {using LiquitySafeMath128 for uint128;using SafeERC20 for IERC20;string public constant NAME = "StabilityPool";address internal troveManagerLiquidationsAddress;address internal whitelistAddress;IBorrowerOperations internal borrowerOperations;ITroveManager internal troveManager;IYUSDToken internal yusdToken;ICommunityIssuance internal communityIssuance;ISortedTroves internal sortedTroves;uint256 internal totalYUSDDeposits;newColls internal totalColl;struct FrontEnd {uint256 kickbackRate;bool registered;}struct Deposit {uint256 initialValue;address frontEndTag;}struct Snapshots {mapping(address => uint256) S;uint256 P;uint256 G;uint128 scale;uint128 epoch;}mapping(address => Deposit) public deposits; // depositor address -> Deposit structmapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots structmapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd structmapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front endmapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots structuint256 public P = DECIMAL_PRECISION;uint256 public constant SCALE_FACTOR = 1e9;uint128 public currentScale;uint128 public currentEpoch;mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;uint256 public lastYETIError;uint256[] public lastAssetError_Offset;uint256 public lastYUSDLossError_Offset;event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);event TroveManagerAddressChanged(address _newTroveManagerAddress);event ActivePoolAddressChanged(address _newActivePoolAddress);event DefaultPoolAddressChanged(address _newDefaultPoolAddress);event YUSDTokenAddressChanged(address _newYUSDTokenAddress);event SortedTrovesAddressChanged(address _newSortedTrovesAddress);event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);event P_Updated(uint256 _P);event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);event EpochUpdated(uint128 _currentEpoch);event ScaleUpdated(uint128 _currentScale);event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);event FrontEndStakeChanged(address indexed _frontEnd,uint256 _newFrontEndStake,address _depositor);event GainsWithdrawn(address indexed _depositor,address[] collaterals,uint256[] _amounts,uint256 _YUSDLoss);event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);function setAddresses(address _borrowerOperationsAddress,address _troveManagerAddress,address _activePoolAddress,address _yusdTokenAddress,address _sortedTrovesAddress,address _communityIssuanceAddress,address _whitelistAddress,address _troveManagerLiquidationsAddress) external override onlyOwner {checkContract(_borrowerOperationsAddress);checkContract(_troveManagerAddress);checkContract(_activePoolAddress);checkContract(_yusdTokenAddress);checkContract(_sortedTrovesAddress);checkContract(_communityIssuanceAddress);checkContract(_whitelistAddress);checkContract(_troveManagerLiquidationsAddress);borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);troveManager = ITroveManager(_troveManagerAddress);activePool = IActivePool(_activePoolAddress);yusdToken = IYUSDToken(_yusdTokenAddress);sortedTroves = ISortedTroves(_sortedTrovesAddress);communityIssuance = ICommunityIssuance(_communityIssuanceAddress);whitelist = IWhitelist(_whitelistAddress);troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;whitelistAddress = _whitelistAddress;emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);emit TroveManagerAddressChanged(_troveManagerAddress);emit ActivePoolAddressChanged(_activePoolAddress);emit YUSDTokenAddressChanged(_yusdTokenAddress);emit SortedTrovesAddressChanged(_sortedTrovesAddress);emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);_renounceOwnership();}function getVC() external view override returns (uint256) {return _getVCColls(totalColl);}function getCollateral(address _collateral) external view override returns (uint256) {uint256 collateralIndex = whitelist.getIndex(_collateral);return totalColl.amounts[collateralIndex];}function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {return (totalColl.tokens, totalColl.amounts);}function getTotalYUSDDeposits() external view override returns (uint256) {return totalYUSDDeposits;}function provideToSP(uint256 _amount, address _frontEndTag) external override {_requireFrontEndIsRegisteredOrZero(_frontEndTag);_requireFrontEndNotRegistered(msg.sender);_requireNonZeroAmount(_amount);uint256 initialDeposit = deposits[msg.sender].initialValue;ICommunityIssuance communityIssuanceCached = communityIssuance;_triggerYETIIssuance(communityIssuanceCached);if (initialDeposit == 0) {_setFrontEndTag(msg.sender, _frontEndTag);}(address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event logaddress frontEnd = deposits[msg.sender].frontEndTag;_payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);_updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);_sendYUSDtoStabilityPool(msg.sender, _amount);uint256 newDeposit = compoundedYUSDDeposit.add(_amount);_updateDepositAndSnapshots(msg.sender, newDeposit);emit UserDepositChanged(msg.sender, newDeposit);emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log_sendGainsToDepositor(msg.sender, assets, amounts);}function withdrawFromSP(uint256 _amount) external override {if (_amount != 0) {_requireNoUnderCollateralizedTroves();}uint256 initialDeposit = deposits[msg.sender].initialValue;_requireUserHasDeposit(initialDeposit);ICommunityIssuance communityIssuanceCached = communityIssuance;_triggerYETIIssuance(communityIssuanceCached);(address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event logaddress frontEnd = deposits[msg.sender].frontEndTag;_payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);_updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);_sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);_updateDepositAndSnapshots(msg.sender, newDeposit);emit UserDepositChanged(msg.sender, newDeposit);emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log_sendGainsToDepositor(msg.sender, assets, amounts);}function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {uint256 YETIIssuance = _communityIssuance.issueYETI();_updateG(YETIIssuance);}function _updateG(uint256 _YETIIssuance) internal {uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOADif (totalYUSD == 0 || _YETIIssuance == 0) {return;}uint256 YETIPerUnitStaked;YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale].add(marginalYETIGain);emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);}function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)internalreturns (uint256){uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));return YETIPerUnitStaked;}function offset(uint256 _debtToOffset,address[] memory _tokens,uint256[] memory _amountsAdded) external override {_requireCallerIsTML();uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOADif (totalYUSD == 0 || _debtToOffset == 0) {return;}_triggerYETIIssuance(communityIssuance);(uint256[] memory AssetGainPerUnitStaked,uint256 YUSDLossPerUnitStaked) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);_updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P_moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);}function _computeRewardsPerUnitStaked(address[] memory _tokens,uint256[] memory _amountsAdded,uint256 _debtToOffset,uint256 _totalYUSDDeposits) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {uint256 amountsLen = _amountsAdded.length;uint256[] memory CollateralNumerators = new uint256[](amountsLen);uint256 currentP = P;for (uint256 i; i < amountsLen; ++i) {uint256 tokenIDX = whitelist.getIndex(_tokens[i]);CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(lastAssetError_Offset[tokenIDX]);}require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");if (_debtToOffset == _totalYUSDDeposits) {YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each depositlastYUSDLossError_Offset = 0;} else {uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(lastYUSDLossError_Offset);YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(YUSDLossNumerator);}AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);for (uint256 i; i < amountsLen; ++i) {AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);}for (uint256 i; i < amountsLen; ++i) {uint256 tokenIDX = whitelist.getIndex(_tokens[i]);lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP));}}function _updateRewardSumAndProduct(address[] memory _assets,uint256[] memory _AssetGainPerUnitStaked,uint256 _YUSDLossPerUnitStaked) internal {uint256 currentP = P;uint256 newP;require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);uint128 currentScaleCached = currentScale;uint128 currentEpochCached = currentEpoch;uint256 assetsLen = _assets.length;for (uint256 i; i < assetsLen; ++i) {address asset = _assets[i];uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);}if (newProductFactor == 0) {currentEpoch = currentEpochCached.add(1);emit EpochUpdated(currentEpoch);currentScale = 0;emit ScaleUpdated(currentScale);newP = DECIMAL_PRECISION;} else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);currentScale = currentScaleCached.add(1);emit ScaleUpdated(currentScale);} else {newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);}require(newP != 0, "SP: P = 0");P = newP;emit P_Updated(newP);}function _moveOffsetCollAndDebt(address[] memory _collsToAdd,uint256[] memory _amountsToAdd,uint256 _debtToOffset) internal {IActivePool activePoolCached = activePool;activePoolCached.decreaseYUSDDebt(_debtToOffset);_decreaseYUSD(_debtToOffset);yusdToken.burn(address(this), _debtToOffset);activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);}function _decreaseYUSD(uint256 _amount) internal {uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);totalYUSDDeposits = newTotalYUSDDeposits;emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);}function getDepositorGains(address _depositor)publicviewoverridereturns (address[] memory, uint256[] memory){uint256 initialDeposit = deposits[_depositor].initialValue;if (initialDeposit == 0) {address[] memory emptyAddress = new address[](0);uint256[] memory emptyUint = new uint256[](0);return (emptyAddress, emptyUint);}Snapshots storage snapshots = depositSnapshots[_depositor];return _calculateGains(initialDeposit, snapshots);}function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)internalviewreturns (address[] memory assets, uint256[] memory amounts){assets = whitelist.getValidCollateral();uint256 assetsLen = assets.length;amounts = new uint256[](assetsLen);for (uint256 i; i < assetsLen; ++i) {amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);}}function _getGainFromSnapshots(uint256 initialDeposit,Snapshots storage snapshots,address asset) internal view returns (uint256) {uint256 S_Snapshot = snapshots.S[asset];uint256 P_Snapshot = snapshots.P;uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(S_Snapshot);uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)].div(SCALE_FACTOR);uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION);return assetGain;}function getDepositorYETIGain(address _depositor) public view override returns (uint256) {uint256 initialDeposit = deposits[_depositor].initialValue;if (initialDeposit == 0) {return 0;}address frontEndTag = deposits[_depositor].frontEndTag;uint256 kickbackRate = frontEndTag == address(0)? DECIMAL_PRECISION: frontEnds[frontEndTag].kickbackRate;Snapshots storage snapshots = depositSnapshots[_depositor];uint256 YETIGain = kickbackRate.mul(_getYETIGainFromSnapshots(initialDeposit, snapshots)).div(DECIMAL_PRECISION);return YETIGain;}function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {uint256 frontEndStake = frontEndStakes[_frontEnd];if (frontEndStake == 0) {return 0;}uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);Snapshots storage snapshots = frontEndSnapshots[_frontEnd];uint256 YETIGain = frontEndShare.mul(_getYETIGainFromSnapshots(frontEndStake, snapshots)).div(DECIMAL_PRECISION);return YETIGain;}function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)internalviewreturns (uint256){uint128 epochSnapshot = snapshots.epoch;uint128 scaleSnapshot = snapshots.scale;uint256 G_Snapshot = snapshots.G;uint256 P_Snapshot = snapshots.P;uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(SCALE_FACTOR);uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(DECIMAL_PRECISION);return YETIGain;}function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {uint256 initialDeposit = deposits[_depositor].initialValue;if (initialDeposit == 0) {return 0;}Snapshots storage snapshots = depositSnapshots[_depositor];uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);return compoundedDeposit;}function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {uint256 frontEndStake = frontEndStakes[_frontEnd];if (frontEndStake == 0) {return 0;}Snapshots storage snapshots = frontEndSnapshots[_frontEnd];uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);return compoundedFrontEndStake;}function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)internalviewreturns (uint256){uint256 snapshot_P = snapshots.P;uint128 scaleSnapshot = snapshots.scale;uint128 epochSnapshot = snapshots.epoch;if (epochSnapshot < currentEpoch) {return 0;}uint256 compoundedStake;uint128 scaleDiff = currentScale.sub(scaleSnapshot);if (scaleDiff == 0) {compoundedStake = initialStake.mul(P).div(snapshot_P);} else if (scaleDiff == 1) {compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);} else {compoundedStake = 0;}if (compoundedStake < initialStake.div(1e9)) {return 0;}return compoundedStake;}function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {yusdToken.sendToPool(_address, address(this), _amount);uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);totalYUSDDeposits = newTotalYUSDDeposits;emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);}function _sendGainsToDepositor(address _to,address[] memory assets,uint256[] memory amounts) internal {uint256 assetsLen = assets.length;require(assetsLen == amounts.length, "SP:Length mismatch");uint256 thisAmounts;address thisAsset;for (uint256 i; i < assetsLen; ++i) {thisAmounts = amounts[i];thisAsset = assets[i];if (whitelist.isWrapped(thisAsset)) {IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);} else {IERC20(thisAsset).safeTransfer(_to, thisAmounts);}}totalColl.amounts = _leftSubColls(totalColl, assets, amounts);}function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {if (YUSDWithdrawal == 0) {return;}yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);_decreaseYUSD(YUSDWithdrawal);}function registerFrontEnd(uint256 _kickbackRate) external override {_requireFrontEndNotRegistered(msg.sender);_requireUserHasNoDeposit(msg.sender);_requireValidKickbackRate(_kickbackRate);frontEnds[msg.sender].kickbackRate = _kickbackRate;frontEnds[msg.sender].registered = true;emit FrontEndRegistered(msg.sender, _kickbackRate);}function _setFrontEndTag(address _depositor, address _frontEndTag) internal {deposits[_depositor].frontEndTag = _frontEndTag;emit FrontEndTagSet(_depositor, _frontEndTag);}function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {deposits[_depositor].initialValue = _newValue;if (_newValue == 0) {delete deposits[_depositor].frontEndTag;address[] memory colls = whitelist.getValidCollateral();uint256 collsLen = colls.length;for (uint256 i; i < collsLen; ++i) {depositSnapshots[_depositor].S[colls[i]] = 0;}depositSnapshots[_depositor].P = 0;depositSnapshots[_depositor].G = 0;depositSnapshots[_depositor].epoch = 0;depositSnapshots[_depositor].scale = 0;emit DepositSnapshotUpdated(_depositor, 0, 0);return;}uint128 currentScaleCached = currentScale;uint128 currentEpochCached = currentEpoch;uint256 currentP = P;address[] memory allColls = whitelist.getValidCollateral();uint256 allCollsLen = allColls.length;for (uint256 i; i < allCollsLen; ++i) {address token = allColls[i];uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][currentScaleCached];depositSnapshots[_depositor].S[token] = currentSForToken;}uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];depositSnapshots[_depositor].P = currentP;depositSnapshots[_depositor].G = currentG;depositSnapshots[_depositor].scale = currentScaleCached;depositSnapshots[_depositor].epoch = currentEpochCached;emit DepositSnapshotUpdated(_depositor, currentP, currentG);}function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {frontEndStakes[_frontEnd] = _newValue;if (_newValue == 0) {delete frontEndSnapshots[_frontEnd];emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);return;}uint128 currentScaleCached = currentScale;uint128 currentEpochCached = currentEpoch;uint256 currentP = P;uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];frontEndSnapshots[_frontEnd].P = currentP;frontEndSnapshots[_frontEnd].G = currentG;frontEndSnapshots[_frontEnd].scale = currentScaleCached;frontEndSnapshots[_frontEnd].epoch = currentEpochCached;emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);}function _payOutYETIGains(ICommunityIssuance _communityIssuance,address _depositor,address _frontEnd) internal {if (_frontEnd != address(0)) {uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);_communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);}uint256 depositorYETIGain = getDepositorYETIGain(_depositor);_communityIssuance.sendYETI(_depositor, depositorYETIGain);emit YETIPaidToDepositor(_depositor, depositorYETIGain);}function _requireNoUnderCollateralizedTroves() internal view {address lowestTrove = sortedTroves.getLast();uint256 ICR = troveManager.getCurrentICR(lowestTrove);require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");}function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {require(_initialDeposit != 0, "SP: require nonzero deposit");}function _requireUserHasNoDeposit(address _address) internal view {uint256 initialDeposit = deposits[_address].initialValue;require(initialDeposit == 0, "SP: User must have no deposit");}function _requireNonZeroAmount(uint256 _amount) internal pure {require(_amount != 0, "SP: Amount must be non-zero");}function _requireFrontEndNotRegistered(address _address) internal view {require(!frontEnds[_address].registered,"SP: Frontend already registered");}function _requireFrontEndIsRegisteredOrZero(address _address) internal view {require(frontEnds[_address].registered || _address == address(0),"SP: Frontend not registered");}function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {require(_kickbackRate <= DECIMAL_PRECISION,"SP:Invalid Kickback rate");}function _requireCallerIsWhitelist() internal view {if (msg.sender != whitelistAddress) {_revertWrongFuncCaller();}}function _requireCallerIsActivePool() internal view {if (msg.sender != address(activePool)) {_revertWrongFuncCaller();}}function _requireCallerIsTML() internal view {if (msg.sender != address(troveManagerLiquidationsAddress)) {_revertWrongFuncCaller();}}function _revertWrongFuncCaller() internal view {revert("SP: External caller not allowed");}function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)externaloverride{_requireCallerIsActivePool();totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);emit StabilityPoolBalancesUpdated(_tokens, _amounts);}function addCollateralType(address _collateral) external override {_requireCallerIsWhitelist();lastAssetError_Offset.push(0);totalColl.tokens.push(_collateral);totalColl.amounts.push(0);}function getDepositSnapshotS(address _depositor, address _collateral)externalviewoverridereturns (uint256){return depositSnapshots[_depositor].S[_collateral];}}