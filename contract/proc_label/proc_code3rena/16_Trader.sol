pragma solidity ^0.8.0;import "./Interfaces/ITracerPerpetualSwaps.sol";import "./Interfaces/Types.sol";import "./Interfaces/ITrader.sol";import "./lib/LibPerpetuals.sol";import "./lib/LibBalances.sol";import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";contract Trader is ITrader {string private constant EIP712_DOMAIN_NAME = "Tracer Protocol";string private constant EIP712_DOMAIN_VERSION = "1.0";bytes32 private constant EIP712_DOMAIN_SEPERATOR =keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");bytes32 private constant ORDER_TYPE =keccak256("Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)");uint256 public constant override chainId = 1337; // Changes per chainbytes32 public immutable override EIP712_DOMAIN;mapping(bytes32 => Perpetuals.Order) public orders;mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;mapping(bytes32 => uint256) public override filled;mapping(bytes32 => uint256) public override averageExecutionPrice;constructor() {EIP712_DOMAIN = keccak256(abi.encode(EIP712_DOMAIN_SEPERATOR,keccak256(bytes(EIP712_DOMAIN_NAME)),keccak256(bytes(EIP712_DOMAIN_VERSION)),chainId,address(this)));}function filledAmount(Perpetuals.Order memory order) external view override returns (uint256) {return filled[Perpetuals.orderId(order)];}function getAverageExecutionPrice(Perpetuals.Order memory order) external view override returns (uint256) {return averageExecutionPrice[Perpetuals.orderId(order)];}function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)externaloverride{require(makers.length == takers.length, "TDR: Lengths differ");uint256 n = makers.length;require(n > 0, "TDR: Received empty arrays");for (uint256 i = 0; i < n; i++) {if (!isValidSignature(makers[i].order.maker, makers[i]) ||!isValidSignature(takers[i].order.maker, takers[i]) ||!isValidPair(takers[i], makers[i])) {continue;}Perpetuals.Order memory makeOrder = grabOrder(makers, i);Perpetuals.Order memory takeOrder = grabOrder(takers, i);bytes32 makerOrderId = Perpetuals.orderId(makeOrder);bytes32 takerOrderId = Perpetuals.orderId(takeOrder);uint256 makeOrderFilled = filled[makerOrderId];uint256 takeOrderFilled = filled[takerOrderId];uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(makeOrderFilled,averageExecutionPrice[makerOrderId],fillAmount,executionPrice);uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(takeOrderFilled,averageExecutionPrice[takerOrderId],fillAmount,executionPrice);(bool success, ) = makeOrder.market.call(abi.encodePacked(ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,abi.encode(makeOrder, takeOrder, fillAmount)));if (!success) continue;filled[makerOrderId] = makeOrderFilled + fillAmount;filled[takerOrderId] = takeOrderFilled + fillAmount;averageExecutionPrice[makerOrderId] = newMakeAverage;averageExecutionPrice[takerOrderId] = newTakeAverage;}}function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index)internalreturns (Perpetuals.Order memory){Perpetuals.Order memory rawOrder = signedOrders[index].order;bytes32 orderHash = Perpetuals.orderId(rawOrder);if (orders[orderHash].maker == address(0)) {orders[orderHash] = rawOrder;orderToSig[orderHash] = signedOrders[index];}return orders[orderHash];}function hashOrder(Perpetuals.Order memory order) public view override returns (bytes32) {returnkeccak256(abi.encodePacked("\x19\x01",EIP712_DOMAIN,keccak256(abi.encode(ORDER_TYPE,order.maker,order.market,order.price,order.amount,uint256(order.side),order.expires,order.created))));}function getDomain() external view override returns (bytes32) {return EIP712_DOMAIN;}function isValidSignature(address signer, Types.SignedLimitOrder memory signedOrder) internal view returns (bool) {return verifySignature(signer, signedOrder);}function isValidPair(Types.SignedLimitOrder memory signedOrder1, Types.SignedLimitOrder memory signedOrder2)internalpurereturns (bool){return (signedOrder1.order.market == signedOrder2.order.market);}function verifySignature(address signer, Types.SignedLimitOrder memory signedOrder)publicviewoverridereturns (bool){returnsigner == ECDSA.recover(hashOrder(signedOrder.order), signedOrder.sigV, signedOrder.sigR, signedOrder.sigS);}function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {bytes32 orderId = Perpetuals.orderId(order);return orders[orderId];}}