pragma solidity ^0.8.0;import "@openzeppelin/contracts/access/Ownable.sol";import "@openzeppelin/contracts/token/ERC20/ERC20.sol";import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";import "@openzeppelin/contracts/utils/Address.sol";import "../../interfaces/IController.sol";import "../../interfaces/IYVault.sol";contract YVault is ERC20, Ownable {using SafeERC20 for ERC20;using Address for address;event Deposit(address indexed depositor, uint256 wantAmount);event Withdrawal(address indexed withdrawer, uint256 wantAmount);struct Rate {uint128 numerator;uint128 denominator;}ERC20 public immutable token;IController public controller;address public farm;Rate internal availableTokensRate;mapping(address => bool) public whitelistedContracts;constructor(address _token,address _controller,Rate memory _availableTokensRate)ERC20(string(abi.encodePacked("JPEG\xE2\x80\x99d ", ERC20(_token).name())),string(abi.encodePacked("JPEGD", ERC20(_token).symbol()))){setController(_controller);setAvailableTokensRate(_availableTokensRate);token = ERC20(_token);}modifier noContract(address _account) {require(!_account.isContract() || whitelistedContracts[_account],"Contracts not allowed");_;}function decimals() public view virtual override returns (uint8) {return token.decimals();}function balance() public view returns (uint256) {returntoken.balanceOf(address(this)) +controller.balanceOf(address(token));}function balanceOfJPEG() external view returns (uint256) {return controller.balanceOfJPEG(address(token));}function setContractWhitelisted(address _contract, bool _isWhitelisted)externalonlyOwner{whitelistedContracts[_contract] = _isWhitelisted;}function setAvailableTokensRate(Rate memory _rate) public onlyOwner {require(_rate.numerator > 0 && _rate.denominator >= _rate.numerator,"INVALID_RATE");availableTokensRate = _rate;}function setController(address _controller) public onlyOwner {require(_controller != address(0), "INVALID_CONTROLLER");controller = IController(_controller);}function setFarmingPool(address _farm) public onlyOwner {require(_farm != address(0), "INVALID_FARMING_POOL");farm = _farm;}function available() public view returns (uint256) {return(token.balanceOf(address(this)) * availableTokensRate.numerator) /availableTokensRate.denominator;}function earn() external {uint256 _bal = available();token.safeTransfer(address(controller), _bal);controller.earn(address(token), _bal);}function depositAll() external {deposit(token.balanceOf(msg.sender));}function deposit(uint256 _amount) public noContract(msg.sender) {require(_amount > 0, "INVALID_AMOUNT");uint256 balanceBefore = balance();token.safeTransferFrom(msg.sender, address(this), _amount);uint256 supply = totalSupply();uint256 shares;if (supply == 0) {shares = _amount;} else {shares = (_amount * supply) / balanceBefore;}_mint(msg.sender, shares);emit Deposit(msg.sender, _amount);}function withdrawAll() external {withdraw(balanceOf(msg.sender));}function withdraw(uint256 _shares) public noContract(msg.sender) {require(_shares > 0, "INVALID_AMOUNT");uint256 supply = totalSupply();require(supply > 0, "NO_TOKENS_DEPOSITED");uint256 backingTokens = (balance() * _shares) / supply;_burn(msg.sender, _shares);uint256 vaultBalance = token.balanceOf(address(this));if (vaultBalance < backingTokens) {uint256 toWithdraw = backingTokens - vaultBalance;controller.withdraw(address(token), toWithdraw);}token.safeTransfer(msg.sender, backingTokens);emit Withdrawal(msg.sender, backingTokens);}function withdrawJPEG() external {require(farm != address(0), "NO_FARM");controller.withdrawJPEG(address(token), farm);}function getPricePerFullShare() external view returns (uint256) {uint256 supply = totalSupply();if (supply == 0) return 0;return (balance() * 1e18) / supply;}function renounceOwnership() public view override onlyOwner {revert("Cannot renounce ownership");}}