pragma solidity ^0.8.11;import "@openzeppelin/contracts/access/Ownable.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";import "@openzeppelin/contracts/security/ReentrancyGuard.sol";import "@openzeppelin/contracts/security/Pausable.sol";import "./external/ConvexInterfaces.sol";import "./interfaces/IConcurRewardClaim.sol";import "./MasterChef.sol";contract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {using SafeERC20 for IERC20;struct RewardType {address token;address pool;uint128 integral;uint128 remaining;}struct Reward {uint128 integral;}address public constant convexBooster =address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);address public constant crv =address(0xD533a949740bb3306d119CC777fa900bA034cd52);address public constant cvx =address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);uint256 public constant CRV_INDEX = 0;uint256 public constant CVX_INDEX = 1;uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000MasterChef public immutable masterChef;mapping(uint256 => address) public convexPool;mapping(uint256 => RewardType[]) public rewards;mapping(uint256 => mapping(uint256 => mapping(address => Reward)))public userReward;mapping(uint256 => mapping(address => uint256)) public registeredRewards;address public treasury;IConcurRewardClaim public claimContract;struct Deposit {uint64 epoch;uint192 amount;}struct WithdrawRequest {uint64 epoch;uint192 amount;}mapping(address => uint256) public pids;mapping(uint256 => mapping(address => Deposit)) public deposits;mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;event Deposited(address indexed _user, uint256 _amount);event Withdrawn(address indexed _user, uint256 _amount);constructor(address _treasury, MasterChef _masterChef) {treasury = _treasury;masterChef = _masterChef;}function pause() external onlyOwner {_pause();}function unpause() external onlyOwner {_unpause();}function changeTreasury(address _treasury) external onlyOwner {treasury = _treasury;}function setRewardPool(address _claimContract) external onlyOwner {claimContract = IConcurRewardClaim(_claimContract);}function addRewards(uint256 _pid) public {address mainPool = IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;if (rewards[_pid].length == 0) {pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;convexPool[_pid] = mainPool;rewards[_pid].push(RewardType({token: crv,pool: mainPool,integral: 0,remaining: 0}));rewards[_pid].push(RewardType({token: cvx,pool: address(0),integral: 0,remaining: 0}));registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1}uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();for (uint256 i = 0; i < extraCount; i++) {address extraPool = IRewardStaking(mainPool).extraRewards(i);address extraToken = IRewardStaking(extraPool).rewardToken();if (extraToken == cvx) {rewards[_pid][CVX_INDEX].pool = extraPool;} else if (registeredRewards[_pid][extraToken] == 0) {rewards[_pid].push(RewardType({token: IRewardStaking(extraPool).rewardToken(),pool: extraPool,integral: 0,remaining: 0}));registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1}}}function rewardLength(uint256 _pid) external view returns (uint256) {return rewards[_pid].length;}function _getDepositedBalance(uint256 _pid, address _account)internalviewvirtualreturns (uint256){return deposits[_pid][_account].amount;}function _getTotalSupply(uint256 _pid)internalviewvirtualreturns (uint256){return IRewardStaking(convexPool[_pid]).balanceOf(address(this));}function _calcRewardIntegral(uint256 _pid,uint256 _index,address _account,uint256 _balance,uint256 _supply) internal {RewardType memory reward = rewards[_pid][_index];uint256 bal = IERC20(reward.token).balanceOf(address(this));uint256 d_reward = bal - reward.remaining;if (reward.token == cvx || reward.token == crv) {IERC20(reward.token).transfer(treasury, d_reward / 5);d_reward = (d_reward * 4) / 5;}IERC20(reward.token).transfer(address(claimContract), d_reward);if (_supply > 0 && d_reward > 0) {reward.integral =reward.integral +uint128((d_reward * 1e20) / _supply);}uint256 userI = userReward[_pid][_index][_account].integral;if (userI < reward.integral) {userReward[_pid][_index][_account].integral = reward.integral;claimContract.pushReward(_account,reward.token,(_balance * (reward.integral - userI)) / 1e20);}if (bal != reward.remaining) {reward.remaining = uint128(bal);}rewards[_pid][_index] = reward;}function _checkpoint(uint256 _pid, address _account) internal {if (paused()) return;uint256 supply = _getTotalSupply(_pid);uint256 depositedBalance = _getDepositedBalance(_pid, _account);IRewardStaking(convexPool[_pid]).getReward(address(this), true);uint256 rewardCount = rewards[_pid].length;for (uint256 i = 0; i < rewardCount; i++) {_calcRewardIntegral(_pid, i, _account, depositedBalance, supply);}}function deposit(uint256 _pid, uint256 _amount)externalwhenNotPausednonReentrant{_checkpoint(_pid, msg.sender);deposits[_pid][msg.sender].epoch = currentEpoch();deposits[_pid][msg.sender].amount += uint192(_amount);if (_amount > 0) {IERC20 lpToken = IERC20(IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken);lpToken.safeTransferFrom(msg.sender, address(this), _amount);lpToken.safeApprove(convexBooster, _amount);IConvexDeposits(convexBooster).deposit(_pid, _amount, true);lpToken.safeApprove(convexBooster, 0);uint256 pid = masterChef.pid(address(lpToken));masterChef.deposit(msg.sender, pid, _amount);}emit Deposited(msg.sender, _amount);}function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), "wait");require(request.amount >= _amount, "too much");_checkpoint(_pid, msg.sender);deposits[_pid][msg.sender].amount -= uint192(_amount);if (_amount > 0) {IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);IERC20 lpToken = IERC20(IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken);lpToken.safeTransfer(msg.sender, _amount);uint256 pid = masterChef.pid(address(lpToken));masterChef.withdraw(msg.sender, pid, _amount);}delete withdrawRequest[_pid][msg.sender];emit Withdrawn(msg.sender, _amount);}function currentEpoch() public view returns(uint64) {return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;}function requestWithdraw(uint256 _pid, uint256 _amount) external {require(_amount <= uint256(deposits[_pid][msg.sender].amount), "too much");withdrawRequest[_pid][msg.sender] = WithdrawRequest({epoch : currentEpoch(),amount : uint192(_amount)});}}