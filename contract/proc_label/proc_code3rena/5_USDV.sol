pragma solidity 0.8.3;import "./interfaces/iERC20.sol";import "./interfaces/iVADER.sol";import "./interfaces/iROUTER.sol";contract USDV is iERC20 {string public override name; string public override symbol;uint public override decimals; uint public override totalSupply;mapping(address => uint) private _balances;mapping(address => mapping(address => uint)) private _allowances;bool private inited;uint public nextEraTime;uint public blockDelay;address public VADER;address public VAULT;address public ROUTER;mapping(address => uint) public lastBlock;modifier onlyDAO() {require(msg.sender == DAO(), "Not DAO");_;}modifier flashProof() {require(isMature(), "No flash");_;}function isMature() public view returns(bool isMatured){if(lastBlock[tx.origin] + blockDelay <= block.number){ // Stops an EOA doing a flash attack in same blockreturn true;}}constructor() {name = 'VADER STABLE DOLLAR';symbol = 'USDV';decimals = 18;totalSupply = 0;}function init(address _vader, address _vault, address _router) external {require(inited == false);inited = true;VADER = _vader;VAULT = _vault;ROUTER = _router;nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();}function balanceOf(address account) public view override returns (uint) {return _balances[account];}function allowance(address owner, address spender) public view virtual override returns (uint) {return _allowances[owner][spender];}function transfer(address recipient, uint amount) external virtual override returns (bool) {_transfer(msg.sender, recipient, amount);return true;}function approve(address spender, uint amount) external virtual override returns (bool) {_approve(msg.sender, spender, amount);return true;}function _approve(address owner, address spender, uint amount) internal virtual {require(owner != address(0), "sender");require(spender != address(0), "spender");_allowances[owner][spender] = amount;emit Approval(owner, spender, amount);}function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {_transfer(sender, recipient, amount);_approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);return true;}function transferTo(address recipient, uint amount) external virtual override returns (bool) {_transfer(tx.origin, recipient, amount);return true;}function _transfer(address sender, address recipient, uint amount) internal virtual {if(amount > 0){                   // Due to design, this function may be called with 0require(sender != address(0), "sender");_balances[sender] -= amount;_balances[recipient] += amount;emit Transfer(sender, recipient, amount);_checkIncentives();}}function _mint(address account, uint amount) internal virtual {if(amount > 0){                   // Due to design, this function may be called with 0require(account != address(0), "recipient");totalSupply += amount;_balances[account] += amount;emit Transfer(address(0), account, amount);}}function burn(uint amount) external virtual override {_burn(msg.sender, amount);}function burnFrom(address account, uint amount) external virtual override {uint decreasedAllowance = allowance(account, msg.sender)- amount;_approve(account, msg.sender, decreasedAllowance);_burn(account, amount);}function _burn(address account, uint amount) internal virtual {if(amount > 0){                   // Due to design, this function may be called with 0require(account != address(0), "address err");_balances[account] -= amount;totalSupply -= amount;emit Transfer(account, address(0), amount);}}function setParams(uint newDelay) external onlyDAO {blockDelay = newDelay;}function _checkIncentives() private {if (block.timestamp >= nextEraTime && emitting()) {         // If new EranextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();uint _balance = iERC20(VADER).balanceOf(address(this));     // Get spare VADERif(_balance > 4){uint _USDVShare = _balance/2;                  // Get 50%_convert(address(this), _USDVShare);              // Convert itif(balanceOf(address(this)) > 2){_transfer(address(this), ROUTER, balanceOf(address(this)) / 2);       // Send half USDV to ROUTER_transfer(address(this), VAULT, balanceOf(address(this)));          // Send rest to VAULT}iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);  // Send half VADER to ROUTERiERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));   // Send rest to VAULT}}}function convert(uint amount) external returns(uint) {return convertForMember(msg.sender, amount);}function convertForMember(address member, uint amount) public returns(uint) {getFunds(VADER, amount);return _convert(member, amount);}function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){if(minting()){lastBlock[tx.origin] = block.number;          // Record firstiERC20(VADER).burn(amount);_convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); // Critical pricing functionality_mint(_member, _convertAmount);}}function redeem(uint amount) external returns(uint) {return redeemForMember(msg.sender, amount);}function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {_transfer(msg.sender, VADER, amount);          // Move fundsredeemAmount = iVADER(VADER).redeemToMember(member);  // Ask VADER to redeemlastBlock[tx.origin] = block.number;          // Must record block AFTER the tx}function getFunds(address token, uint amount) internal {if(token == address(this)){_transfer(msg.sender, address(this), amount);} else {if(tx.origin==msg.sender){require(iERC20(token).transferTo(address(this), amount));}else{require(iERC20(token).transferFrom(msg.sender, address(this), amount));}}}function DAO() public view returns(address){return iVADER(VADER).DAO();}function emitting() public view returns(bool){return iVADER(VADER).emitting();}function minting() public view returns(bool){return iVADER(VADER).minting();}}