pragma solidity ^0.6.11;pragma experimental ABIEncoderV2;import "../deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";import "../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";import "../deps/@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol";import "../deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";import "../deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol";import "../interfaces/uniswap/IUniswapRouterV2.sol";import "../interfaces/badger/ISettV3.sol";import "../interfaces/badger/IController.sol";import "../interfaces/cvx/ICvxLocker.sol";import "../interfaces/snapshot/IDelegateRegistry.sol";import {BaseStrategy} from "../deps/BaseStrategy.sol";contract MyStrategy is BaseStrategy {using SafeERC20Upgradeable for IERC20Upgradeable;using AddressUpgradeable for address;using SafeMathUpgradeable for uint256;uint256 MAX_BPS = 10_000;address public lpComponent; // Token we provide liquidity withaddress public reward; // Token we farm and swap to want / lpComponentaddress public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;address public constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;address public constant SUSHI_ROUTER =0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;IDelegateRegistry public constant SNAPSHOT =IDelegateRegistry(0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446);address public constant DELEGATE =0xB65cef03b9B89f99517643226d76e286ee999e77;bytes32 public constant DELEGATED_SPACE =0x6376782e65746800000000000000000000000000000000000000000000000000;ICvxLocker public LOCKER;ISettV3 public CVX_VAULT =ISettV3(0x53C8E199eb2Cb7c01543C137078a038937a68E40);bool public withdrawalSafetyCheck = true;bool public harvestOnRebalance = true;bool public processLocksOnReinvest = true;bool public processLocksOnRebalance = true;event Debug(string name, uint256 value);event TreeDistribution(address indexed token,uint256 amount,uint256 indexed blockNumber,uint256 timestamp);function initialize(address _governance,address _strategist,address _controller,address _keeper,address _guardian,address[3] memory _wantConfig,uint256[3] memory _feeConfig,address _locker ///@dev TODO: Add this to deploy) public initializer {__BaseStrategy_init(_governance,_strategist,_controller,_keeper,_guardian);want = _wantConfig[0];lpComponent = _wantConfig[1];reward = _wantConfig[2];performanceFeeGovernance = _feeConfig[0];performanceFeeStrategist = _feeConfig[1];withdrawalFee = _feeConfig[2];LOCKER = ICvxLocker(_locker); //TODO: Make locker hardcoded at top of fileIERC20Upgradeable(CVX).safeApprove(_locker, type(uint256).max);IERC20Upgradeable(CVX).safeApprove(address(CVX_VAULT),type(uint256).max);IERC20Upgradeable(reward).safeApprove(SUSHI_ROUTER, type(uint256).max);SNAPSHOT.setDelegate(DELEGATED_SPACE, DELEGATE);}function setWithdrawalSafetyCheck(bool newWithdrawalSafetyCheck) public {_onlyGovernance();withdrawalSafetyCheck = newWithdrawalSafetyCheck;}function setHarvestOnRebalance(bool newHarvestOnRebalance) public {_onlyGovernance();harvestOnRebalance = newHarvestOnRebalance;}function setProcessLocksOnReinvest(bool newProcessLocksOnReinvest) public {_onlyGovernance();processLocksOnReinvest = newProcessLocksOnReinvest;}function setProcessLocksOnRebalance(bool newProcessLocksOnRebalance)public{_onlyGovernance();processLocksOnRebalance = newProcessLocksOnRebalance;}function getName() external pure override returns (string memory) {return "veCVX Voting Strategy";}function version() external pure returns (string memory) {return "1.0";}function CVXToWant(uint256 cvx) public view returns (uint256) {uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare();return cvx.mul(10**18).div(bCVXToCVX);}function wantToCVX(uint256 want) public view returns (uint256) {uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare();return want.mul(bCVXToCVX).div(10**18);}function balanceOfPool() public view override returns (uint256) {if (withdrawalSafetyCheck) {uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimalsrequire(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of peg}uint256 valueInLocker =CVXToWant(LOCKER.lockedBalanceOf(address(this))).add(CVXToWant(IERC20Upgradeable(CVX).balanceOf(address(this))));return (valueInLocker);}function isTendable() public view override returns (bool) {return false;}function getProtectedTokens()publicviewoverridereturns (address[] memory){address[] memory protectedTokens = new address[](4);protectedTokens[0] = want;protectedTokens[1] = lpComponent;protectedTokens[2] = reward;protectedTokens[3] = CVX;return protectedTokens;}function setKeepReward(uint256 _setKeepReward) external {_onlyGovernance();}function _onlyNotProtectedTokens(address _asset) internal override {address[] memory protectedTokens = getProtectedTokens();for (uint256 x = 0; x < protectedTokens.length; x++) {require(address(protectedTokens[x]) != _asset,"Asset is protected");}}function _deposit(uint256 _amount) internal override {CVX_VAULT.withdraw(_amount);uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());}function prepareWithdrawAll() external {_onlyGovernance();LOCKER.processExpiredLocks(false);uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));if (toDeposit > 0) {CVX_VAULT.deposit(toDeposit);}}function _withdrawAll() internal override {require(LOCKER.lockedBalanceOf(address(this)) == 0 &&LOCKER.balanceOf(address(this)) == 0,"You have to wait for unlock and have to manually rebalance out of it");}function _withdrawSome(uint256 _amount)internaloverridereturns (uint256){uint256 max = IERC20Upgradeable(want).balanceOf(address(this));if (withdrawalSafetyCheck) {uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimalsrequire(bCVXToCVX > 10**18, "Loss Of Peg"); // Avoid trying to redeem for less / loss of pegrequire(max >= _amount.mul(9_980).div(MAX_BPS),"Withdrawal Safety Check"); // 20 BP of slippage}if (max < _amount) {return max;}return _amount;}function harvest() public whenNotPaused returns (uint256 harvested) {_onlyAuthorizedActors();uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));LOCKER.getReward(address(this), false);uint256 earnedReward =IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);(uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =_processRewardsFees(earnedReward, reward);_swapcvxCRVToWant();uint256 earned =IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);emit Harvest(earned, block.number);return earned;}function tend() external whenNotPaused {_onlyAuthorizedActors();revert(); // NOTE: For now tend is replaced by manualRebalance}function _swapcvxCRVToWant() internal {uint256 toSwap = IERC20Upgradeable(reward).balanceOf(address(this));if (toSwap == 0) {return;}address[] memory path = new address[](3);path[0] = reward;path[1] = WETH;path[2] = CVX;IUniswapRouterV2(SUSHI_ROUTER).swapExactTokensForTokens(toSwap,0,path,address(this),now);uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));if (toDeposit > 0) {CVX_VAULT.deposit(toDeposit);}}function _processPerformanceFees(uint256 _amount)internalreturns (uint256 governancePerformanceFee,uint256 strategistPerformanceFee){governancePerformanceFee = _processFee(want,_amount,performanceFeeGovernance,IController(controller).rewards());strategistPerformanceFee = _processFee(want,_amount,performanceFeeStrategist,strategist);}function _processRewardsFees(uint256 _amount, address _token)internalreturns (uint256 governanceRewardsFee, uint256 strategistRewardsFee){governanceRewardsFee = _processFee(_token,_amount,performanceFeeGovernance,IController(controller).rewards());strategistRewardsFee = _processFee(_token,_amount,performanceFeeStrategist,strategist);}function reinvest() external whenNotPaused returns (uint256 reinvested) {_onlyGovernance();if (processLocksOnReinvest) {LOCKER.processExpiredLocks(false);}uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());}function manualProcessExpiredLocks() external whenNotPaused {_onlyGovernance();LOCKER.processExpiredLocks(false);}function manualDepositCVXIntoVault() external whenNotPaused {_onlyGovernance();uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));if (toDeposit > 0) {CVX_VAULT.deposit(toDeposit);}}function manualSendbCVXToVault() external whenNotPaused {_onlyGovernance();uint256 bCvxAmount = IERC20Upgradeable(want).balanceOf(address(this));_transferToVault(bCvxAmount);}function manualRebalance(uint256 toLock) external whenNotPaused {_onlyGovernance();require(toLock <= MAX_BPS, "Max is 100%");if (processLocksOnRebalance) {LOCKER.processExpiredLocks(false);}if (harvestOnRebalance) {harvest();}uint256 balanceOfWant =IERC20Upgradeable(want).balanceOf(address(this));uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));uint256 balanceInLock = LOCKER.balanceOf(address(this));uint256 totalCVXBalance =balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));uint256 currentLockRatio =balanceInLock.mul(10**18).div(totalCVXBalance);uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);uint256 toWantRatio =totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);if (newLockRatio <= currentLockRatio) {uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));if (toDeposit > 0) {CVX_VAULT.deposit(toDeposit);}return;}uint256 cvxToLock = newLockRatio.sub(currentLockRatio);uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));if (cvxToLock > maxCVX) {LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());} else {LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());}uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));if (cvxLeft > 0) {CVX_VAULT.deposit(cvxLeft);}}}