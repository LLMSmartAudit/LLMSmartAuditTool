pragma solidity ^0.8.0;import "@openzeppelin/contracts/access/Ownable.sol";import "./lib/LibMath.sol";import "./lib/LibLiquidation.sol";import "./lib/LibBalances.sol";import "./lib/LibPerpetuals.sol";import "./Interfaces/ILiquidation.sol";import "./Interfaces/ITrader.sol";import "./Interfaces/ITracerPerpetualSwaps.sol";import "./Interfaces/ITracerPerpetualsFactory.sol";import "./Interfaces/IOracle.sol";import "./Interfaces/IPricing.sol";import "./Interfaces/IInsurance.sol";contract Liquidation is ILiquidation, Ownable {using LibMath for uint256;using LibMath for int256;uint256 public override currentLiquidationId;uint256 public override maxSlippage;uint256 public override releaseTime = 15 minutes;uint256 public override minimumLeftoverGasCostMultiplier = 10;IPricing public pricing;ITracerPerpetualSwaps public tracer;address public insuranceContract;address public fastGasOracle;mapping(uint256 => LibLiquidation.LiquidationReceipt) public liquidationReceipts;event ClaimedReceipts(address indexed liquidator, address indexed market, uint256 indexed receiptId);event ClaimedEscrow(address indexed liquidatee, address indexed market, uint256 indexed id);event Liquidate(address indexed account,address indexed liquidator,int256 liquidationAmount,Perpetuals.Side side,address indexed market,uint256 liquidationId);event InvalidClaimOrder(uint256 indexed receiptId);liquidated position. Given as a decimal WAD. e.g 5% = 0.05*10^18constructor(address _pricing,address _tracer,address _insuranceContract,address _fastGasOracle,uint256 _maxSlippage) Ownable() {pricing = IPricing(_pricing);tracer = ITracerPerpetualSwaps(_tracer);insuranceContract = _insuranceContract;fastGasOracle = _fastGasOracle;maxSlippage = _maxSlippage;}function submitLiquidation(address liquidator,address liquidatee,uint256 price,uint256 escrowedAmount,int256 amountLiquidated,Perpetuals.Side liquidationSide) internal {liquidationReceipts[currentLiquidationId] = LibLiquidation.LiquidationReceipt({tracer: address(tracer),liquidator: liquidator,liquidatee: liquidatee,price: price,time: block.timestamp,escrowedAmount: escrowedAmount,releaseTime: block.timestamp + releaseTime,amountLiquidated: amountLiquidated,escrowClaimed: false,liquidationSide: liquidationSide,liquidatorRefundClaimed: false});currentLiquidationId += 1;}function claimEscrow(uint256 receiptId) public override {LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];require(!receipt.escrowClaimed, "LIQ: Escrow claimed");require(block.timestamp > receipt.releaseTime, "LIQ: Not released");liquidationReceipts[receiptId].escrowClaimed = true;int256 amountToReturn = receipt.escrowedAmount.toInt256();emit ClaimedEscrow(receipt.liquidatee, receipt.tracer, receiptId);tracer.updateAccountsOnClaim(address(0), 0, receipt.liquidatee, amountToReturn, 0);}function getLiquidationReceipt(uint256 id)externalviewoverridereturns (LibLiquidation.LiquidationReceipt memory){return liquidationReceipts[id];}function verifyAndSubmitLiquidation(int256 base,uint256 price,int256 quote,int256 amount,uint256 gasPrice,address account) internal returns (uint256) {require(amount > 0, "LIQ: Liquidation amount <= 0");require(tx.gasprice <= IOracle(fastGasOracle).latestAnswer(), "LIQ: GasPrice > FGasPrice");Balances.Position memory pos = Balances.Position(quote, base);uint256 gasCost = gasPrice * tracer.LIQUIDATION_GAS_COST();int256 currentMargin = Balances.margin(pos, price);require(currentMargin <= 0 ||uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),"LIQ: Account above margin");require(amount <= base.abs(), "LIQ: Liquidate Amount > Position");uint256 amountToEscrow = LibLiquidation.calcEscrowLiquidationAmount(Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),currentMargin,amount,base);Perpetuals.Side side = base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long;submitLiquidation(msg.sender, account, price, amountToEscrow, amount, side);return amountToEscrow;}function checkPartialLiquidation(Balances.Position memory updatedPosition, uint256 lastUpdatedGasPrice)publicviewreturns (bool){uint256 liquidationGasCost = tracer.LIQUIDATION_GAS_COST();uint256 price = pricing.fairPrice();returnLibLiquidation.partialLiquidationIsValid(updatedPosition,lastUpdatedGasPrice,liquidationGasCost,price,minimumLeftoverGasCostMultiplier);}function liquidate(int256 amount, address account) external override {Balances.Account memory liquidatedBalance = tracer.getBalance(account);uint256 amountToEscrow = verifyAndSubmitLiquidation(liquidatedBalance.position.base,pricing.fairPrice(),liquidatedBalance.position.quote,amount,liquidatedBalance.lastUpdatedGasPrice,account);(int256 liquidatorQuoteChange,int256 liquidatorBaseChange,int256 liquidateeQuoteChange,int256 liquidateeBaseChange) = LibLiquidation.liquidationBalanceChanges(liquidatedBalance.position.base,liquidatedBalance.position.quote,amount);Balances.Position memory updatedPosition = Balances.Position(liquidatedBalance.position.quote + liquidateeQuoteChange,liquidatedBalance.position.base + liquidateeBaseChange);require(checkPartialLiquidation(updatedPosition, liquidatedBalance.lastUpdatedGasPrice),"LIQ: leaves too little left over");tracer.updateAccountsOnLiquidation(msg.sender,account,liquidatorQuoteChange,liquidatorBaseChange,liquidateeQuoteChange,liquidateeBaseChange,amountToEscrow);emit Liquidate(account,msg.sender,amount,(liquidatedBalance.position.base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long),address(tracer),currentLiquidationId - 1);}function calcUnitsSold(Perpetuals.Order[] memory orders,address traderContract,uint256 receiptId) public override returns (uint256, uint256) {LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];uint256 unitsSold;uint256 avgPrice;for (uint256 i; i < orders.length; i++) {Perpetuals.Order memory order = ITrader(traderContract).getOrder(orders[i]);if (order.created < receipt.time || // Order made before receiptorder.maker != receipt.liquidator || // Order made by someone who isn't liquidatororder.side == receipt.liquidationSide // Order is in same direction as liquidation) {emit InvalidClaimOrder(receiptId);continue;}if ((receipt.liquidationSide == Perpetuals.Side.Long && order.price >= receipt.price) ||(receipt.liquidationSide == Perpetuals.Side.Short && order.price <= receipt.price)) {emit InvalidClaimOrder(receiptId);continue;}uint256 orderFilled = ITrader(traderContract).filledAmount(order);uint256 averageExecutionPrice = ITrader(traderContract).getAverageExecutionPrice(order);unitsSold = unitsSold + orderFilled;avgPrice = avgPrice + (averageExecutionPrice * orderFilled);}if (unitsSold == 0) {return (0, 0);}return (unitsSold, avgPrice / unitsSold);}function calcAmountToReturn(uint256 escrowId,Perpetuals.Order[] memory orders,address traderContract) public override returns (uint256) {LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[escrowId];(uint256 unitsSold, uint256 avgPrice) = calcUnitsSold(orders, traderContract, escrowId);require(unitsSold <= uint256(receipt.amountLiquidated.abs()), "LIQ: Unit mismatch");uint256 amountToReturn = LibLiquidation.calculateSlippage(unitsSold, maxSlippage, avgPrice, receipt);return amountToReturn;}function drainInsurancePoolOnLiquidation(uint256 amountWantedFromInsurance,LibLiquidation.LiquidationReceipt memory receipt) internal returns (uint256 _amountTakenFromInsurance, uint256 _amountToGiveToClaimant) {Balances.Account memory insuranceBalance = tracer.getBalance(insuranceContract);if (insuranceBalance.position.quote >= amountWantedFromInsurance.toInt256()) {_amountTakenFromInsurance = amountWantedFromInsurance;} else {if (insuranceBalance.position.quote <= 0) {IInsurance(insuranceContract).drainPool(amountWantedFromInsurance);} else {IInsurance(insuranceContract).drainPool(amountWantedFromInsurance - uint256(insuranceBalance.position.quote));}Balances.Account memory updatedInsuranceBalance = tracer.getBalance(insuranceContract);if (updatedInsuranceBalance.position.quote < amountWantedFromInsurance.toInt256()) {_amountTakenFromInsurance = uint256(updatedInsuranceBalance.position.quote);} else {_amountTakenFromInsurance = amountWantedFromInsurance;}}_amountToGiveToClaimant = receipt.escrowedAmount + _amountTakenFromInsurance;}function claimReceipt(uint256 receiptId,Perpetuals.Order[] memory orders,address traderContract) external override {LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];require(receipt.liquidator == msg.sender, "LIQ: Liquidator mismatch");require(!receipt.liquidatorRefundClaimed, "LIQ: Already claimed");liquidationReceipts[receiptId].liquidatorRefundClaimed = true;liquidationReceipts[receiptId].escrowClaimed = true;require(block.timestamp < receipt.releaseTime, "LIQ: claim time passed");require(tracer.tradingWhitelist(traderContract), "LIQ: Trader is not whitelisted");uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);if (amountToReturn > receipt.escrowedAmount) {liquidationReceipts[receiptId].escrowedAmount = 0;} else {liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;}uint256 amountTakenFromInsurance;uint256 amountToGiveToClaimant;uint256 amountToGiveToLiquidatee;if (amountToReturn > receipt.escrowedAmount) {uint256 amountWantedFromInsurance = amountToReturn - receipt.escrowedAmount;(amountTakenFromInsurance, amountToGiveToClaimant) = drainInsurancePoolOnLiquidation(amountWantedFromInsurance,receipt);} else {amountToGiveToClaimant = amountToReturn;amountToGiveToLiquidatee = receipt.escrowedAmount - amountToReturn;}tracer.updateAccountsOnClaim(receipt.liquidator,amountToGiveToClaimant.toInt256(),receipt.liquidatee,amountToGiveToLiquidatee.toInt256(),amountTakenFromInsurance.toInt256());emit ClaimedReceipts(msg.sender, address(tracer), receiptId);}function transferOwnership(address newOwner) public override(Ownable, ILiquidation) onlyOwner {super.transferOwnership(newOwner);}function setReleaseTime(uint256 _releaseTime) external onlyOwner() {releaseTime = _releaseTime;}function setMinimumLeftoverGasCostMultiplier(uint256 _minimumLeftoverGasCostMultiplier) external onlyOwner() {minimumLeftoverGasCostMultiplier = _minimumLeftoverGasCostMultiplier;}function setMaxSlippage(uint256 _maxSlippage) public override onlyOwner() {maxSlippage = _maxSlippage;}}