pragma solidity ^0.8.7;import "./libs/SignatureValidatorV2.sol";contract Identity {mapping (address => bytes32) public privileges;uint public nonce = 0;event LogPrivilegeChanged(address indexed addr, bytes32 priv);event LogErr(address indexed to, uint value, bytes data, bytes returnData); // only used in tryCatchstruct Transaction {address to;uint value;bytes data;}constructor(address[] memory addrs) {uint len = addrs.length;for (uint i=0; i<len; i++) {privileges[addrs[i]] = bytes32(uint(1));emit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));}}receive() external payable {}fallback() external payable {bytes4 method = msg.sig;if (method == 0x150b7a02 // bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))|| method == 0xf23a6e61 // bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))|| method == 0xbc197c81 // bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))) {assembly {calldatacopy(0, 0, 0x04)return (0, 0x20)}}}function setAddrPrivilege(address addr, bytes32 priv)external{require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))require(priv != bytes32(uint(1)), 'UNSETTING_SPECIAL_DATA');privileges[addr] = priv;emit LogPrivilegeChanged(addr, priv);}function tipMiner(uint amount)external{require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');executeCall(block.coinbase, amount, new bytes(0));}function tryCatch(address to, uint value, bytes calldata data)external{require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);if (!success) emit LogErr(to, value, data, returnData);}function execute(Transaction[] calldata txns, bytes calldata signature)external{require(txns.length > 0, 'MUST_PASS_TX');uint currentNonce = nonce;bytes32 hash = keccak256(abi.encode(address(this), block.chainid, currentNonce, txns));nonce = currentNonce + 1;address signer = SignatureValidator.recoverAddrImpl(hash, signature, true);require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');uint len = txns.length;for (uint i=0; i<len; i++) {Transaction memory txn = txns[i];executeCall(txn.to, txn.value, txn.data);}require(privileges[signer] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');}function executeBySender(Transaction[] calldata txns) external {require(txns.length > 0, 'MUST_PASS_TX');require(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');uint len = txns.length;for (uint i=0; i<len; i++) {Transaction memory txn = txns[i];executeCall(txn.to, txn.value, txn.data);}require(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');}function executeCall(address to, uint256 value, bytes memory data)internal{assembly {let result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)switch result case 0 {let size := returndatasize()let ptr := mload(0x40)returndatacopy(ptr, 0, size)revert(ptr, size)}default {}}}function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {if (privileges[SignatureValidator.recoverAddr(hash, signature)] != bytes32(0)) {return 0x1626ba7e;} else {return 0xffffffff;}}function supportsInterface(bytes4 interfaceID) external pure returns (bool) {returninterfaceID == 0x01ffc9a7 ||  // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).interfaceID == 0x4e2312e0;   // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")) ^ bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`).}}