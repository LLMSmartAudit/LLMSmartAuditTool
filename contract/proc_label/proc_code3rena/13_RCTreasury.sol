pragma solidity 0.8.4;import "@openzeppelin/contracts/access/Ownable.sol";import "@openzeppelin/contracts/utils/math/SafeCast.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "hardhat/console.sol";import "./lib/NativeMetaTransaction.sol";import "./interfaces/IRCTreasury.sol";import "./interfaces/IRCMarket.sol";import "./interfaces/IRCOrderbook.sol";import "./interfaces/IRCNftHubL2.sol";import "./interfaces/IRCFactory.sol";import "./interfaces/IRCBridge.sol";contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {║       VARIABLES      ║╚═════════════════════════════════╝*/IRCOrderbook public orderbook;IRCNftHubL2 public nfthub;IERC20 public override erc20;address public override bridgeAddress;address public override factoryAddress;mapping(address => bool) public override isMarket;uint256 public override totalDeposits;mapping(address => uint256) public override marketPot;uint256 public override totalMarketPots;uint256 public marketBalance;mapping(address => bool) public override isForeclosed;uint256 marketBalanceDiscrepancy;struct User {uint128 deposit;uint128 rentalRate;uint128 bidRate;uint64 lastRentCalc;uint64 lastRentalTime;}mapping(address => User) public user;║   GOVERNANCE VARIABLES    ║╚═════════════════════════════════╝*/uint256 public override minRentalDayDivisor;uint256 public override maxContractBalance;mapping(address => bool) public isAllowed;bool public whitelistEnabled;║       SAFETY       ║╚═════════════════════════════════╝*/bool public override globalPause;mapping(address => bool) public override marketPaused;║      UBER OWNER      ║╚═════════════════════════════════╝*/address public override uberOwner;║       EVENTS       ║╚═════════════════════════════════╝*/event LogUserForeclosed(address indexed user, bool indexed foreclosed);event LogAdjustDeposit(address indexed user,uint256 indexed amount,bool increase);event LogMarketPaused(address market, bool paused);event LogGlobalPause(bool paused);║      CONSTRUCTOR      ║╚═════════════════════════════════╝*/constructor(address _tokenAddress) {_initializeEIP712("RealityCardsTreasury", "1");uberOwner = msgSender();setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutessetMaxContractBalance(1000000 ether); // 1msetTokenAddress(_tokenAddress);whitelistEnabled = true;}║      MODIFIERS       ║╚═════════════════════════════════╝*/modifier balancedBooks {_;require(erc20.balanceOf(address(this)) >=totalDeposits + marketBalance + totalMarketPots,"Books are unbalanced!");}modifier onlyMarkets {require(isMarket[msgSender()], "Not authorised");_;}modifier onlyOrderbook {require(msgSender() == address(orderbook), "Not authorised");_;}║      ADD MARKETS      ║╚═════════════════════════════════╝*/function addMarket(address _newMarket) external override {require(msgSender() == factoryAddress, "Not factory");isMarket[_newMarket] = true;}║    GOVERNANCE - OWNER    ║╚═════════════════════════════════╝*/│ CALLED WITHIN CONSTRUTOR - PUBLIC │└────────────────────────────────────┘*/function setMinRental(uint256 _newDivisor) public override onlyOwner {minRentalDayDivisor = _newDivisor;}function setMaxContractBalance(uint256 _newBalanceLimit)publicoverrideonlyOwner{maxContractBalance = _newBalanceLimit;}│ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL │└──────────────────────────────────────────┘*/function changeGlobalPause() external override onlyOwner {globalPause = !globalPause;emit LogGlobalPause(globalPause);}function changePauseMarket(address _market) external override onlyOwner {require(isMarket[_market], "This isn't a market");marketPaused[_market] = !marketPaused[_market];emit LogMarketPaused(_market, marketPaused[_market]);}║   WHITELIST FUNCTIONS    ║╚═════════════════════════════════╝*/function toggleWhitelist() external override onlyOwner {whitelistEnabled = !whitelistEnabled;}function addToWhitelist(address _user) public override {IRCFactory factory = IRCFactory(factoryAddress);require(factory.isGovernor(msgSender()), "Not authorised");isAllowed[_user] = !isAllowed[_user];}function batchAddToWhitelist(address[] calldata _users) public override {for (uint256 index = 0; index < _users.length; index++) {addToWhitelist(_users[index]);}}║   GOVERNANCE - UBER OWNER   ║╠═════════════════════════════════╣║ ******** DANGER ZONE ******** ║╚═════════════════════════════════╝*/function setFactoryAddress(address _newFactory) external override {require(msgSender() == uberOwner, "Extremely Verboten");require(_newFactory != address(0), "Must set an address");factoryAddress = _newFactory;}function setOrderbookAddress(address _newOrderbook) external {require(msgSender() == uberOwner, "Extremely Verboten");require(_newOrderbook != address(0), "Must set an address");orderbook = IRCOrderbook(_newOrderbook);}function setNftHubAddress(address _NFTHubAddress) external {require(msgSender() == uberOwner, "Extremely Verboten");require(_NFTHubAddress != address(0), "Must set an address");nfthub = IRCNftHubL2(_NFTHubAddress);}function setTokenAddress(address _newToken) public override {require(msgSender() == uberOwner, "Extremely Verboten");require(_newToken != address(0), "Must set an address");erc20 = IERC20(_newToken);}function setBridgeAddress(address _newBridge) public override {require(msgSender() == uberOwner, "Extremely Verboten");require(_newBridge != address(0), "Must set an address");bridgeAddress = _newBridge;erc20.approve(_newBridge, type(uint256).max);}function changeUberOwner(address _newUberOwner) external override {require(msgSender() == uberOwner, "Extremely Verboten");require(_newUberOwner != address(0), "Must set an address");uberOwner = _newUberOwner;}║ DEPOSIT AND WITHDRAW FUNCTIONS ║╚═════════════════════════════════╝*/function deposit(uint256 _amount, address _user)publicoverridebalancedBooksreturns (bool){require(!globalPause, "Deposits are disabled");require(erc20.allowance(msgSender(), address(this)) >= _amount,"User not approved to send this amount");require((erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,"Limit hit");require(_amount > 0, "Must deposit something");if (whitelistEnabled) {require(isAllowed[msgSender()], "Not in whitelist");}erc20.transferFrom(msgSender(), address(this), _amount);orderbook.removeOldBids(_user);user[_user].deposit += SafeCast.toUint128(_amount);totalDeposits += _amount;emit LogAdjustDeposit(_user, _amount, true);if ((user[_user].deposit + _amount) >(user[_user].bidRate / minRentalDayDivisor)) {isForeclosed[_user] = false;emit LogUserForeclosed(_user, false);}return true;}function withdrawDeposit(uint256 _amount, bool _localWithdrawal)externaloverridebalancedBooks{require(!globalPause, "Withdrawals are disabled");address _msgSender = msgSender();require(user[_msgSender].deposit > 0, "Nothing to withdraw");require(user[_msgSender].bidRate == 0 ||block.timestamp - (user[_msgSender].lastRentalTime) >uint256(1 days) / minRentalDayDivisor,"Too soon");collectRentUser(_msgSender, block.timestamp);if (_amount > user[_msgSender].deposit) {_amount = user[_msgSender].deposit;}emit LogAdjustDeposit(_msgSender, _amount, false);user[_msgSender].deposit -= SafeCast.toUint128(_amount);totalDeposits -= _amount;if (_localWithdrawal) {erc20.transfer(_msgSender, _amount);} else {IRCBridge bridge = IRCBridge(bridgeAddress);bridge.withdrawToMainnet(_msgSender, _amount);}if (user[_msgSender].bidRate != 0 &&user[_msgSender].bidRate / (minRentalDayDivisor) >user[_msgSender].deposit) {isForeclosed[_msgSender] = true;isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(_msgSender);emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);}}function topupMarketBalance(uint256 _amount) external override {erc20.transferFrom(msgSender(), address(this), _amount);if (_amount > marketBalanceDiscrepancy) {marketBalanceDiscrepancy = 0;} else {marketBalanceDiscrepancy -= _amount;}marketBalance += _amount;}║     ERC20 helpers      ║╚═════════════════════════════════╝*/function checkSponsorship(address sender, uint256 _amount)externalviewoverride{require(erc20.allowance(sender, address(this)) >= _amount,"Insufficient Allowance");require(erc20.balanceOf(sender) >= _amount, "Insufficient Balance");}║    MARKET CALLABLE     ║╚═════════════════════════════════╝*/function payRent(uint256 _amount)externaloverridebalancedBooksonlyMarketsreturns (bool){require(!globalPause, "Rentals are disabled");if (marketBalance < _amount) {marketBalanceDiscrepancy += _amount - marketBalance;_amount -= (_amount - marketBalance);}address _market = msgSender();marketBalance -= _amount;marketPot[_market] += _amount;totalMarketPots += _amount;return true;}function payout(address _user, uint256 _amount)externaloverridebalancedBooksonlyMarketsreturns (bool){require(!globalPause, "Payouts are disabled");assert(marketPot[msgSender()] >= _amount);user[_user].deposit += SafeCast.toUint128(_amount);marketPot[msgSender()] -= _amount;totalMarketPots -= _amount;totalDeposits += _amount;emit LogAdjustDeposit(_user, _amount, true);return true;}function refundUser(address _user, uint256 _refund)externaloverrideonlyMarkets{marketBalance -= _refund;user[_user].deposit += SafeCast.toUint128(_refund);totalDeposits += _refund;emit LogAdjustDeposit(_user, _refund, true);if (isForeclosed[_user] &&user[_user].deposit > user[_user].bidRate / minRentalDayDivisor) {isForeclosed[_user] = false;emit LogUserForeclosed(_user, false);}}function sponsor(address _sponsor, uint256 _amount)externaloverridebalancedBooksonlyMarketsreturns (bool){require(!globalPause, "Global Pause is Enabled");require(erc20.allowance(_sponsor, address(this)) >= _amount,"Not approved to send this amount");erc20.transferFrom(_sponsor, address(this), _amount);marketPot[msgSender()] += _amount;totalMarketPots += _amount;return true;}function updateLastRentalTime(address _user)externaloverrideonlyMarketsreturns (bool){user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);if (user[_user].lastRentCalc == 0) {user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);}return true;}║    MARKET HELPERS      ║╚═════════════════════════════════╝*/function userTotalBids(address _user)externalviewoverridereturns (uint256){return user[_user].bidRate;}function userDeposit(address _user)externalviewoverridereturns (uint256){return uint256(user[_user].deposit);}║   ORDERBOOK CALLABLE     ║╚═════════════════════════════════╝*/function updateRentalRate(address _oldOwner,address _newOwner,uint256 _oldPrice,uint256 _newPrice,uint256 _timeOwnershipChanged) external override onlyOrderbook {if (_timeOwnershipChanged != user[_newOwner].lastRentCalc &&!isMarket[_newOwner]) {if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {uint256 _additionalRentOwed =rentOwedBetweenTimestmaps(block.timestamp,_timeOwnershipChanged,_newPrice);collectRentUser(_newOwner, block.timestamp);_increaseMarketBalance(_additionalRentOwed, _newOwner);} else {if (user[_newOwner].rentalRate != 0) {collectRentUser(_newOwner, _timeOwnershipChanged);} else {user[_newOwner].lastRentCalc = SafeCast.toUint64(_timeOwnershipChanged);}}}user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);}function increaseBidRate(address _user, uint256 _price)externaloverrideonlyOrderbook{user[_user].bidRate += SafeCast.toUint128(_price);}function decreaseBidRate(address _user, uint256 _price)externaloverrideonlyOrderbook{user[_user].bidRate -= SafeCast.toUint128(_price);}function resetUser(address _user) external override onlyOrderbook {isForeclosed[_user] = false;}║   RENT CALC HELPERS     ║╚═════════════════════════════════╝*/function rentOwedUser(address _user, uint256 _timeOfCollection)internalviewreturns (uint256 rentDue){return(user[_user].rentalRate *(_timeOfCollection - user[_user].lastRentCalc)) / (1 days);}function rentOwedBetweenTimestmaps(uint256 _time1,uint256 _time2,uint256 _price) internal pure returns (uint256 _rent) {if (_time1 < _time2) {(_time1, _time2) = (_time2, _time1);}_rent = (_price * (_time1 - _time2)) / (1 days);}function depositAbleToWithdraw(address _user)internalviewreturns (uint256){uint256 collection = rentOwedUser(_user, block.timestamp);if (collection >= user[_user].deposit) {return 0;} else {return uint256(user[_user].deposit) - (collection);}}function foreclosureTimeUser(address _user,uint256 _newBid,uint256 _timeOfNewBid) external view override returns (uint256) {uint256 totalUserDailyRent = user[_user].rentalRate;if (totalUserDailyRent > 0) {uint256 timeLeftOfDeposit =(depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;uint256 foreclosureTimeWithoutNewCard =user[_user].lastRentCalc + timeLeftOfDeposit;if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {uint256 _rentAlreadyOwed =rentOwedBetweenTimestmaps(user[_user].lastRentCalc,_timeOfNewBid,totalUserDailyRent);uint256 _depositAtTimeOfNewBid =user[_user].deposit - _rentAlreadyOwed;uint256 _timeLeftOfDepositWithNewBid =(_depositAtTimeOfNewBid * 1 days) /(totalUserDailyRent + _newBid);return _timeOfNewBid + _timeLeftOfDepositWithNewBid;} else {return user[_user].lastRentCalc + timeLeftOfDeposit;}} else {return type(uint256).max;}}function collectRentUser(address _user, uint256 _timeToCollectTo)publicoverridereturns (uint256 newTimeLastCollectedOnForeclosure){require(!globalPause, "Global pause is enabled");assert(_timeToCollectTo != 0);if (user[_user].lastRentCalc < _timeToCollectTo) {uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {uint256 previousCollectionTime = user[_user].lastRentCalc;timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)= (now - previousCollectionTime) * (usersDeposit/rentOwed)uint256 timeUsersDepositLasts =((_timeToCollectTo - previousCollectionTime) *uint256(user[_user].deposit)) / rentOwedByUser;Users last collection time = previousCollectionTime + timeTheirDepsitLastedrentOwedByUser = uint256(user[_user].deposit);newTimeLastCollectedOnForeclosure =previousCollectionTime +timeUsersDepositLasts;_increaseMarketBalance(rentOwedByUser, _user);user[_user].lastRentCalc = SafeCast.toUint64(newTimeLastCollectedOnForeclosure);assert(user[_user].deposit == 0);isForeclosed[_user] = true;emit LogUserForeclosed(_user, true);} else {_increaseMarketBalance(rentOwedByUser, _user);user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);}emit LogAdjustDeposit(_user, rentOwedByUser, false);}}function _increaseMarketBalance(uint256 rentCollected, address _user)internal{marketBalance += rentCollected;user[_user].deposit -= SafeCast.toUint128(rentCollected);totalDeposits -= rentCollected;}▲▲ ▲}