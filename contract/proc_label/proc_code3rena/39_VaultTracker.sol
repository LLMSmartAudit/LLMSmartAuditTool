pragma solidity 0.8.4;import "./Abstracts.sol";contract VaultTracker {struct Vault {uint256 notional;uint256 redeemable;uint256 exchangeRate;}mapping(address => Vault) public vaults;address public immutable admin;address public immutable cTokenAddr;address public immutable swivel;bool public matured;uint256 public immutable maturity;uint256 public maturityRate;constructor(uint256 m, address c, address s) {admin = msg.sender;maturity = m;cTokenAddr = c;swivel = s;}function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();Vault memory vlt = vaults[o];if (vlt.notional > 0) {uint256 yield;uint256 interest;if (matured) { // Calculate marginal interestyield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;} else {yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;}interest = (yield * vlt.notional) / 1e26;vlt.redeemable += interest;vlt.notional += a;} else {vlt.notional = a;}vlt.exchangeRate = exchangeRate;vaults[o] = vlt;return true;}function removeNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {Vault memory vlt = vaults[o];require(vlt.notional >= a, "amount exceeds vault balance");uint256 yield;uint256 interest;uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();if (matured) { // Calculate marginal interestyield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;} else {yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;}interest = (yield * vlt.notional) / 1e26;vlt.redeemable += interest;vlt.notional -= a;vlt.exchangeRate = exchangeRate;vaults[o] = vlt;return true;}function redeemInterest(address o) external onlyAdmin(admin) returns (uint256) {Vault memory vlt = vaults[o];uint256 redeemable = vlt.redeemable;uint256 yield;uint256 interest;uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();if (matured) { // Calculate marginal interestyield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;} else {yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;}interest = (yield * vlt.notional) / 1e26;vlt.exchangeRate = exchangeRate;vlt.redeemable = 0;vaults[o] = vlt;return (redeemable + interest);}function matureVault() external onlyAdmin(admin) returns (bool) {require(!matured, 'already matured');require(block.timestamp >= maturity, 'maturity has not been reached');matured = true;maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();return true;}function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {Vault memory from = vaults[f];Vault memory to = vaults[t];require(from.notional >= a, "amount exceeds available balance");uint256 yield;uint256 interest;uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();if (matured) {yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;} else {yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;}interest = (yield * from.notional) / 1e26;from.redeemable += interest;from.notional -= a;from.exchangeRate = exchangeRate;vaults[f] = from;if (to.notional > 0) {uint256 newVaultInterest;if (matured) {yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;} else {yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;}newVaultInterest = (yield * to.notional) / 1e26;to.redeemable += newVaultInterest;to.notional += a;} else {to.notional += a;}to.exchangeRate = exchangeRate;vaults[t] = to;return true;}function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {Vault memory oVault = vaults[f];Vault memory sVault = vaults[swivel];oVault.notional -= a;uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();uint256 yield;uint256 interest;if (sVault.exchangeRate != exchangeRate) {if (sVault.exchangeRate != 0) {if (matured) {yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;} else {yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;}interest = (yield * sVault.notional) / 1e26;sVault.redeemable += interest;}sVault.exchangeRate = exchangeRate;}sVault.notional += a;vaults[swivel] = sVault;vaults[f] = oVault;return true;}function balancesOf(address o) public view returns (uint256, uint256) {return (vaults[o].notional, vaults[o].redeemable);}modifier onlyAdmin(address a) {require(msg.sender == a, 'sender must be admin');_;}}