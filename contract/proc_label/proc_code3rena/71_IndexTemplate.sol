pragma solidity 0.8.7;import "hardhat/console.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";import "./InsureDAOERC20.sol";import "./interfaces/IIndexTemplate.sol";import "./interfaces/IUniversalMarket.sol";import "./interfaces/IVault.sol";import "./interfaces/IRegistry.sol";import "./interfaces/IParameters.sol";import "./interfaces/IPoolTemplate.sol";import "./interfaces/ICDSTemplate.sol";contract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {event Deposit(address indexed depositor, uint256 amount, uint256 mint);event WithdrawRequested(address indexed withdrawer,uint256 amount,uint256 time);event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);event Compensated(address indexed index, uint256 amount);event Paused(bool paused);event Resumed();event Locked();event MetadataChanged(string metadata);event LeverageSet(uint256 target);event AllocationSet(uint256 indexed _index,address indexed pool,uint256 allocPoint);bool public initialized;bool public paused;bool public locked;uint256 public pendingEnd;string public metadata;IParameters public parameters;IVault public vault;IRegistry public registry;uint256 public totalAllocatedCredit; //total allocated credit(liquidity)mapping(address => uint256) public allocPoints; //allocation point for each pooluint256 public totalAllocPoint; //total allocation pointaddress[] public poolList; //list of all poolsuint256 public targetLev; //1x = MAGIC_SCALE_1E6struct Withdrawal {uint256 timestamp;uint256 amount;}mapping(address => Withdrawal) public withdrawalReq;struct PoolStatus {uint256 current;uint256 available;uint256 allocation;address addr;}uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncationmodifier onlyOwner() {require(msg.sender == parameters.getOwner(),"Restricted: caller is not allowed to operate");_;}constructor() {initialized = true;}function initialize(string calldata _metaData,uint256[] calldata _conditions,address[] calldata _references) external override {require(initialized == false &&bytes(_metaData).length > 0 &&_references[0] != address(0) &&_references[1] != address(0) &&_references[2] != address(0),"ERROR: INITIALIZATION_BAD_CONDITIONS");initialized = true;string memory _name = "InsureDAO-Index";string memory _symbol = "iIndex";uint8 _decimals = IERC20Metadata(_references[0]).decimals();initializeToken(_name, _symbol, _decimals);parameters = IParameters(_references[2]);vault = IVault(parameters.getVault(_references[0]));registry = IRegistry(_references[1]);metadata = _metaData;}function deposit(uint256 _amount) public returns (uint256 _mintAmount) {require(locked == false && paused == false, "ERROR: DEPOSIT_DISABLED");require(_amount > 0, "ERROR: DEPOSIT_ZERO");uint256 _supply = totalSupply();uint256 _totalLiquidity = totalLiquidity();vault.addValue(_amount, msg.sender, address(this));if (_supply > 0 && _totalLiquidity > 0) {_mintAmount = (_amount * _supply) / _totalLiquidity;} else if (_supply > 0 && _totalLiquidity == 0) {_mintAmount = _amount * _supply;} else {_mintAmount = _amount;}emit Deposit(msg.sender, _amount, _mintAmount);_mint(msg.sender, _mintAmount);uint256 _liquidityAfter = _totalLiquidity + _amount;uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /_liquidityAfter;if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {_adjustAlloc(_liquidityAfter);}}function requestWithdraw(uint256 _amount) external {uint256 _balance = balanceOf(msg.sender);require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE");require(_amount > 0, "ERROR: REQUEST_ZERO");withdrawalReq[msg.sender].timestamp = block.timestamp;withdrawalReq[msg.sender].amount = _amount;emit WithdrawRequested(msg.sender, _amount, block.timestamp);}function withdraw(uint256 _amount) external returns (uint256 _retVal) {uint256 _liquidty = totalLiquidity();uint256 _lockup = parameters.getLockup(msg.sender);uint256 _requestTime = withdrawalReq[msg.sender].timestamp;_retVal = (_liquidty * _amount) / totalSupply();require(locked == false, "ERROR: WITHDRAWAL_PENDING");require(_requestTime + _lockup < block.timestamp,"ERROR: WITHDRAWAL_QUEUE");require(_requestTime + _lockup + parameters.getWithdrawable(msg.sender) >block.timestamp,"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST");require(withdrawalReq[msg.sender].amount >= _amount,"ERROR: WITHDRAWAL_EXCEEDED_REQUEST");require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");require(_retVal <= withdrawable(),"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY");withdrawalReq[msg.sender].amount -= _amount;_burn(msg.sender, _amount);uint256 _liquidityAfter = _liquidty - _retVal;if (_liquidityAfter > 0) {uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /_liquidityAfter;if (targetLev + parameters.getUpperSlack(address(this)) < _leverage) {_adjustAlloc(_liquidityAfter);}} else {_adjustAlloc(0);}vault.withdrawValue(_retVal, msg.sender);emit Withdraw(msg.sender, _amount, _retVal);}function withdrawable() public view returns (uint256 _retVal) {uint256 _totalLiquidity = totalLiquidity();if(_totalLiquidity > 0){uint256 _length = poolList.length;uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;uint256 _targetAllocPoint;uint256 _targetLockedCreditScore;for (uint256 i = 0; i < _length; i++) {address _poolAddress = poolList[i];uint256 _allocPoint = allocPoints[_poolAddress];if (_allocPoint > 0) {uint256 _allocated = IPoolTemplate(_poolAddress).allocatedCredit(address(this));uint256 _availableBalance = IPoolTemplate(_poolAddress).availableBalance();if (_allocated > _availableBalance) {uint256 _availableRate = (_availableBalance *MAGIC_SCALE_1E6) / _allocated;uint256 _lockedCredit = _allocated - _availableBalance;if (i == 0 || _availableRate < _lowestAvailableRate) {_lowestAvailableRate = _availableRate;_targetLockedCreditScore = _lockedCredit;_targetAllocPoint = _allocPoint;}}}}if (_lowestAvailableRate == MAGIC_SCALE_1E6) {_retVal = _totalLiquidity;} else {uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint / _targetAllocPoint;_necessaryAmount = _necessaryAmount * MAGIC_SCALE_1E6 / targetLev;if(_necessaryAmount < _totalLiquidity){_retVal = _totalLiquidity - _necessaryAmount;}else{_retVal = 0;}}}}function adjustAlloc() public {_adjustAlloc(totalLiquidity());}function _adjustAlloc(uint256 _liquidity) internal {uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;uint256 _allocatable = _targetCredit;uint256 _allocatablePoints = totalAllocPoint;uint256 _length = poolList.length;PoolStatus[] memory _poolList = new PoolStatus[](_length);for (uint256 i = 0; i < _length; i++) {address _pool = poolList[i];if (_pool != address(0)) {uint256 _allocation = allocPoints[_pool];uint256 _target = (_targetCredit * _allocation) /_allocatablePoints;uint256 _current = IPoolTemplate(_pool).allocatedCredit(address(this));uint256 _available = IPoolTemplate(_pool).availableBalance();if ((_current > _target && _current - _target > _available) ||IPoolTemplate(_pool).paused() == true) {IPoolTemplate(_pool).withdrawCredit(_available);totalAllocatedCredit -= _available;_poolList[i].addr = address(0);_allocatable -= _current - _available;_allocatablePoints -= _allocation;} else {_poolList[i].addr = _pool;_poolList[i].current = _current;_poolList[i].available = _available;_poolList[i].allocation = _allocation;}}}for (uint256 i = 0; i < _length; i++) {if (_poolList[i].addr != address(0)) {uint256 _target = (_allocatable * _poolList[i].allocation) /_allocatablePoints;uint256 _current = _poolList[i].current;uint256 _available = _poolList[i].available;if (_current > _target && _available != 0) {uint256 _decrease = _current - _target;IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);totalAllocatedCredit -= _decrease;}if (_current < _target) {uint256 _allocate = _target - _current;IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);totalAllocatedCredit += _allocate;}if (_current == _target) {IPoolTemplate(_poolList[i].addr).allocateCredit(0);}}}}function compensate(uint256 _amount)externaloverridereturns (uint256 _compensated){require(allocPoints[msg.sender] > 0,"ERROR_COMPENSATE_UNAUTHORIZED_CALLER");uint256 _value = vault.underlyingValue(address(this));if (_value >= _amount) {vault.offsetDebt(_amount, msg.sender);_compensated = _amount;} else {uint256 _shortage;if (totalLiquidity() < _amount) {_shortage = _amount - _value;uint256 _cds = ICDSTemplate(registry.getCDS(address(this))).compensate(_shortage);_compensated = _value + _cds;}vault.offsetDebt(_compensated, msg.sender);}adjustAlloc();emit Compensated(msg.sender, _compensated);}function resume() external override {uint256 _poolLength = poolList.length;for (uint256 i = 0; i < _poolLength; i++) {require(IPoolTemplate(poolList[i]).paused() == false,"ERROR: POOL_IS_PAUSED");}locked = false;emit Resumed();}function lock() external override {require(allocPoints[msg.sender] > 0);locked = true;emit Locked();}function leverage() public view returns (uint256 _rate) {if (totalLiquidity() > 0) {return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();} else {return 0;}}function totalLiquidity() public view returns (uint256 _balance) {return vault.underlyingValue(address(this)) + _accruedPremiums();}function rate() external view returns (uint256) {if (totalSupply() > 0) {return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();} else {return 0;}}function valueOfUnderlying(address _owner) public view returns (uint256) {uint256 _balance = balanceOf(_owner);if (_balance == 0) {return 0;} else {return (_balance * totalLiquidity()) / totalSupply();}}function getAllPools() external view returns (address[] memory) {return poolList;}function setPaused(bool _state) external override onlyOwner {if (paused != _state) {paused = _state;emit Paused(_state);}}function changeMetadata(string calldata _metadata)externaloverrideonlyOwner{metadata = _metadata;emit MetadataChanged(_metadata);}function setLeverage(uint256 _target) external override onlyOwner {targetLev = _target;adjustAlloc();emit LeverageSet(_target);}function set(uint256 _index,address _pool,uint256 _allocPoint) public override onlyOwner {require(registry.isListed(_pool), "ERROR:UNREGISTERED_POOL");require(_index <= parameters.getMaxList(address(this)),"ERROR: EXCEEEDED_MAX_INDEX");uint256 _length = poolList.length;if (_length <= _index) {require(_length == _index, "ERROR: BAD_INDEX");poolList.push(_pool);} else {address _poolAddress = poolList[_index];if (_poolAddress != address(0) && _poolAddress != _pool) {uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(address(this));IPoolTemplate(_poolAddress).withdrawCredit(_current);}poolList[_index] = _pool;}if (totalAllocPoint > 0) {totalAllocPoint =totalAllocPoint -allocPoints[_pool] +_allocPoint;} else {totalAllocPoint = _allocPoint;}allocPoints[_pool] = _allocPoint;adjustAlloc();emit AllocationSet(_index, _pool, _allocPoint);}function _beforeTokenTransfer(address from,address to,uint256 amount) internal virtual override {super._beforeTokenTransfer(from, to, amount);if (from != address(0)) {uint256 _after = balanceOf(from) - amount;if (_after < withdrawalReq[from].amount) {withdrawalReq[from].amount = _after;}}}function _accruedPremiums() internal view returns (uint256 _totalValue) {for (uint256 i = 0; i < poolList.length; i++) {if (allocPoints[poolList[i]] > 0) {_totalValue =_totalValue +IPoolTemplate(poolList[i]).pendingPremium(address(this));}}}}