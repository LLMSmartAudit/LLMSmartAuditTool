pragma solidity 0.8.9;import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";import "../../../interfaces/IGasBank.sol";import "../../../interfaces/pool/ILiquidityPool.sol";import "../../../interfaces/ISwapperRegistry.sol";import "../../../interfaces/IController.sol";import "../../../interfaces/IStakerVault.sol";import "../../../interfaces/ISwapper.sol";import "../../../interfaces/actions/topup/ITopUpHandler.sol";import "../../../interfaces/actions/topup/ITopUpAction.sol";import "../../../interfaces/actions/IActionFeeHandler.sol";import "../../../libraries/AddressProviderHelpers.sol";import "../../../libraries/Errors.sol";import "../../../libraries/ScaledMath.sol";import "../../../libraries/EnumerableExtensions.sol";import "../../access/Authorization.sol";import "../../utils/Preparable.sol";library TopUpActionLibrary {using SafeERC20 for IERC20;using ScaledMath for uint256;using AddressProviderHelpers for IAddressProvider;function lockFunds(address stakerVaultAddress,address payer,address token,uint256 lockAmount,uint256 depositAmount) external {uint256 amountLeft = lockAmount;IStakerVault stakerVault = IStakerVault(stakerVaultAddress);if (depositAmount > 0) {depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;IERC20(token).safeTransferFrom(payer, address(this), depositAmount);IERC20(token).safeApprove(stakerVaultAddress, depositAmount);stakerVault.stake(depositAmount);stakerVault.increaseActionLockedBalance(payer, depositAmount);amountLeft -= depositAmount;}if (amountLeft > 0) {uint256 balance = stakerVault.balanceOf(payer);uint256 allowance = stakerVault.allowance(payer, address(this));uint256 availableFunds = balance < allowance ? balance : allowance;if (availableFunds >= amountLeft) {stakerVault.transferFrom(payer, address(this), amountLeft);amountLeft = 0;}}require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);}function calcExchangeAmount(IAddressProvider addressProvider,address token,address actionToken,uint256 amount) external view returns (uint256) {ILiquidityPool pool = addressProvider.getPoolForToken(token);uint256 rate = pool.exchangeRate();address underlying = pool.getUnderlying();if (underlying == actionToken) {return amount.scaledDivRoundUp(rate);}ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);uint256 swapperRate = swapper.getRate(underlying, actionToken);return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));}function getSwapper(IAddressProvider addressProvider,address underlying,address actionToken) public view returns (ISwapper) {address swapperRegistry = addressProvider.getSwapperRegistry();address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);return ISwapper(swapper);}}contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {using ScaledMath for uint256;using ScaledMath for uint128;using SafeERC20 for IERC20;using EnumerableSet for EnumerableSet.AddressSet;using EnumerableSet for EnumerableSet.Bytes32Set;using EnumerableExtensions for EnumerableSet.AddressSet;using AddressProviderHelpers for IAddressProvider;struct ExecuteLocalVars {uint256 minActionAmountToTopUp;uint256 actionTokenAmount;uint256 depositTotalFeesAmount;uint256 actionAmountWithFees;uint256 userFactor;uint256 rate;uint256 depositAmountWithFees;uint256 depositAmountWithoutFees;uint256 actionFee;uint256 totalActionTokenAmount;uint128 totalTopUpAmount;bool success;bytes topupResult;uint256 gasBankBalance;uint256 initialGas;uint256 gasConsumed;uint256 userGasPrice;uint256 estimatedRequiredGas;uint256 estimatedRequiredWeiForGas;uint256 requiredWeiForGas;uint256 reimbursedWeiForGas;address underlying;bool removePosition;}EnumerableSet.AddressSet private _usableTokens;uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;IController public immutable controller;IAddressProvider public immutable addressProvider;EnumerableSet.Bytes32Set internal _supportedProtocols;mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;mapping(address => RecordMeta[]) internal _userPositions;EnumerableSet.AddressSet internal _usersWithPositions;constructor(IController _controller)Authorization(_controller.addressProvider().getRoleManager()){controller = _controller;addressProvider = controller.addressProvider();_setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);}receive() external payable {}function initialize(address feeHandler,bytes32[] calldata protocols,address[] calldata handlers) external initializer onlyGovernance {require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);_setConfig(_FEE_HANDLER_KEY, feeHandler);_setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);for (uint256 i = 0; i < protocols.length; i++) {bytes32 protocolKey = _getProtocolKey(protocols[i]);_setConfig(protocolKey, handlers[i]);_updateTopUpHandler(protocols[i], address(0), handlers[i]);}}function register(bytes32 account,bytes32 protocol,uint128 depositAmount,Record memory record) external payable returns (bool) {require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);require(_positions[msg.sender][account][protocol].threshold == 0,Error.POSITION_ALREADY_EXISTS);require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *record.maxFee *getEstimatedGasUsage();require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);uint256 totalLockAmount = _calcExchangeAmount(record.depositToken,record.actionToken,record.totalTopUpAmount);_lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);record.depositTokenBalance = uint128(totalLockAmount);_positions[msg.sender][account][protocol] = record;_userPositions[msg.sender].push(RecordMeta(account, protocol));_usersWithPositions.add(msg.sender);emit Register(account,protocol,record.threshold,msg.sender,record.depositToken,totalLockAmount,record.actionToken,record.singleTopUpAmount,record.totalTopUpAmount,record.maxFee,record.extra);return true;}function execute(address payer,bytes32 account,address beneficiary,bytes32 protocol) external override returns (bool) {return execute(payer, account, beneficiary, protocol, 0);}function resetPosition(bytes32 account,bytes32 protocol,bool unstake) external override returns (bool) {address payer = msg.sender;Record memory position = _positions[payer][account][protocol];require(position.threshold != 0, Error.NO_POSITION_EXISTS);address vault = addressProvider.getStakerVault(position.depositToken);IStakerVault staker = IStakerVault(vault);staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);if (unstake) {staker.unstake(position.depositTokenBalance);IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);} else {staker.transfer(payer, position.depositTokenBalance);}_removePosition(payer, account, protocol);addressProvider.getGasBank().withdrawUnused(payer);return true;}function executeTopUpHandler(bytes32 protocol) external override returns (address) {address oldHandler = _getHandler(protocol, false);address newHandler = _executeAddress(_getProtocolKey(protocol));_updateTopUpHandler(protocol, oldHandler, newHandler);return newHandler;}function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {return _resetAddressConfig(_getProtocolKey(protocol));}function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);return _prepare(_ACTION_FEE_KEY, newActionFee);}function executeActionFee() external override returns (uint256) {return _executeUInt256(_ACTION_FEE_KEY);}function resetActionFee() external onlyGovernance returns (bool) {return _resetUInt256Config(_ACTION_FEE_KEY);}function prepareSwapperSlippage(uint256 newSwapperSlippage)externalonlyGovernancereturns (bool){require(newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,Error.INVALID_AMOUNT);return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);}function executeSwapperSlippage() external override returns (uint256) {return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);}function resetSwapperSlippage() external onlyGovernance returns (bool) {return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);}function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {return _prepare(_FEE_HANDLER_KEY, handler);}function executeFeeHandler() external override returns (address) {return _executeAddress(_FEE_HANDLER_KEY);}function resetFeeHandler() external onlyGovernance returns (bool) {return _resetAddressConfig(_FEE_HANDLER_KEY);}function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);}function executeEstimatedGasUsage() external returns (uint256) {return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);}function resetGasUsage() external onlyGovernance returns (bool) {return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);}function addUsableToken(address token) external override onlyGovernance returns (bool) {return _usableTokens.add(token);}function getEthRequiredForGas(address payer) external view override returns (uint256) {uint256 totalEthRequired = 0;RecordMeta[] memory userRecordsMeta = _userPositions[payer];uint256 gasUsagePerCall = getEstimatedGasUsage();uint256 length = userRecordsMeta.length;for (uint256 i = 0; i < length; i++) {RecordMeta memory meta = userRecordsMeta[i];Record memory record = _positions[payer][meta.account][meta.protocol];uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;}return totalEthRequired;}function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {return _userPositions[payer];}function getSupportedProtocols() external view override returns (bytes32[] memory) {uint256 length = _supportedProtocols.length();bytes32[] memory protocols = new bytes32[](length);for (uint256 i = 0; i < length; i++) {protocols[i] = _supportedProtocols.at(i);}return protocols;}function usersWithPositions(uint256 cursor, uint256 howMany)externalviewoverridereturns (address[] memory users, uint256 nextCursor){uint256 length = _usersWithPositions.length();if (cursor >= length) return (new address[](0), 0);if (howMany >= length - cursor) {howMany = length - cursor;}address[] memory usersWithPositions_ = new address[](howMany);for (uint256 i = 0; i < howMany; i++) {usersWithPositions_[i] = _usersWithPositions.at(i + cursor);}return (usersWithPositions_, cursor + howMany);}function getUsableTokens() external view override returns (address[] memory) {return _usableTokens.toArray();}function getTopUpHandler(bytes32 protocol) external view returns (address) {return _getHandler(protocol, false);}function execute(address payer,bytes32 account,address beneficiary,bytes32 protocol,uint256 maxWeiForGas) public override returns (bool) {require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);ExecuteLocalVars memory vars;vars.initialGas = gasleft();Record storage position = _positions[payer][account][protocol];require(position.threshold != 0, Error.NO_POSITION_EXISTS);require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);address topUpHandler = _getHandler(protocol, true);vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);IGasBank gasBank = addressProvider.getGasBank();vars.estimatedRequiredGas = getEstimatedGasUsage();vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;vars.userGasPrice = block.basefee + position.priorityFee;if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;require(vars.estimatedRequiredWeiForGas <=vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,Error.ESTIMATED_GAS_TOO_HIGH);vars.gasBankBalance = gasBank.balanceOf(payer);require(vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,Error.GAS_BANK_BALANCE_TOO_LOW);vars.totalTopUpAmount = position.totalTopUpAmount;vars.actionFee = getActionFee();vars.minActionAmountToTopUp = position.singleTopUpAmount;vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(ScaledMath.ONE + vars.actionFee);if (vars.actionAmountWithFees > vars.totalTopUpAmount) {vars.actionAmountWithFees = vars.totalTopUpAmount;vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(ScaledMath.ONE + vars.actionFee);}ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);vars.underlying = pool.getUnderlying();vars.rate = pool.exchangeRate();ISwapper swapper;if (vars.underlying != position.actionToken) {swapper = _getSwapper(vars.underlying, position.actionToken);vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));}vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);if (position.depositTokenBalance < vars.depositAmountWithFees) {vars.depositAmountWithFees = position.depositTokenBalance;vars.minActionAmountToTopUp =(vars.depositAmountWithFees * vars.rate) /(ScaledMath.ONE + vars.actionFee);}vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;address vault = addressProvider.getStakerVault(position.depositToken);IStakerVault(vault).unstake(vars.depositAmountWithFees);IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);if (address(swapper) != address(0)) {vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(getSwapperSlippage());_approve(vars.underlying, address(swapper));vars.actionTokenAmount = swapper.swap(vars.underlying,position.actionToken,vars.actionTokenAmount,vars.minActionAmountToTopUp);}vars.totalActionTokenAmount =vars.actionTokenAmount +vars.depositTotalFeesAmount.scaledMul(vars.rate);(vars.success, vars.topupResult) = topUpHandler.delegatecall(abi.encodeWithSignature("topUp(bytes32,address,uint256,bytes)",account,position.actionToken,vars.actionTokenAmount,position.extra));require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);} else {position.totalTopUpAmount = 0;}position.depositTokenBalance -= uint128(vars.depositAmountWithFees);vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;_payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);if (vars.removePosition) {if (position.depositTokenBalance > 0) {IStakerVault(vault).transfer(payer, position.depositTokenBalance);IStakerVault(vault).decreaseActionLockedBalance(payer,position.depositTokenBalance);}_removePosition(payer, account, protocol);}emit TopUp(account,protocol,payer,position.depositToken,vars.depositAmountWithFees,position.actionToken,vars.actionTokenAmount);vars.gasConsumed = vars.initialGas - gasleft();vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;if (vars.reimbursedWeiForGas > vars.gasBankBalance) {vars.reimbursedWeiForGas = vars.gasBankBalance;}vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;require(vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,Error.GAS_TOO_HIGH);gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);if (vars.removePosition) {gasBank.withdrawUnused(payer);}return true;}function prepareTopUpHandler(bytes32 protocol, address newHandler)publiconlyGovernancereturns (bool){return _prepare(_getProtocolKey(protocol), newHandler);}function getHealthFactor(bytes32 protocol,bytes32 account,bytes memory extra) public view override returns (uint256 healthFactor) {ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));return topUpHandler.getUserFactor(account, extra);}function getHandler(bytes32 protocol) public view override returns (address) {return _getHandler(protocol, false);}function getEstimatedGasUsage() public view returns (uint256) {return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];}function getActionFee() public view override returns (uint256) {return currentUInts256[_ACTION_FEE_KEY];}function getSwapperSlippage() public view override returns (uint256) {return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];}function getFeeHandler() public view override returns (address) {return currentAddresses[_FEE_HANDLER_KEY];}function getPosition(address payer,bytes32 account,bytes32 protocol) public view override returns (Record memory) {return _positions[payer][account][protocol];}function isUsable(address token) public view override returns (bool) {return _usableTokens.contains(token);}function _updateTopUpHandler(bytes32 protocol,address oldHandler,address newHandler) internal {if (newHandler == address(0)) {_supportedProtocols.remove(protocol);} else if (oldHandler == address(0)) {_supportedProtocols.add(protocol);}}function _payFees(address payer,address beneficiary,uint256 feeAmount,address depositToken) internal {address feeHandler = getFeeHandler();IERC20(depositToken).safeApprove(feeHandler, feeAmount);IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);}function _lockFunds(address payer,address token,uint256 lockAmount,uint256 depositAmount) internal {address stakerVaultAddress = addressProvider.getStakerVault(token);TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);}function _removePosition(address payer,bytes32 account,bytes32 protocol) internal {delete _positions[payer][account][protocol];_removeUserPosition(payer, account, protocol);if (_userPositions[payer].length == 0) {_usersWithPositions.remove(payer);}emit Deregister(payer, account, protocol);}function _removeUserPosition(address payer,bytes32 account,bytes32 protocol) internal {RecordMeta[] storage positionsMeta = _userPositions[payer];uint256 length = positionsMeta.length;for (uint256 i = 0; i < length; i++) {RecordMeta storage positionMeta = positionsMeta[i];if (positionMeta.account == account && positionMeta.protocol == protocol) {positionsMeta[i] = positionsMeta[length - 1];positionsMeta.pop();return;}}}function _approve(address token, address spender) internal {if (IERC20(token).allowance(address(this), spender) > 0) return;IERC20(token).safeApprove(spender, type(uint256).max);}function _calcExchangeAmount(address token,address actionToken,uint256 amount) internal view returns (uint256) {return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);}function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);}function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {address handler = currentAddresses[_getProtocolKey(protocol)];require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);return handler;}function _isSwappable(address depositToken, address toToken) internal view returns (bool) {ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);address underlying = pool.getUnderlying();if (underlying == toToken) {return true;}address swapperRegistry = addressProvider.getSwapperRegistry();return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);}function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));}}