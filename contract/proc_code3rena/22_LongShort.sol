pragma solidity 0.8.3;import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "./interfaces/ITokenFactory.sol";import "./interfaces/ISyntheticToken.sol";import "./interfaces/IStaker.sol";import "./interfaces/ILongShort.sol";import "./interfaces/IYieldManager.sol";import "./interfaces/IOracleManager.sol";contract LongShort is ILongShort, Initializable {║     VARIABLES     ║╚═════════════════════════════╝*/address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;uint256[45] private __constantsGap;address public admin;address public treasury;uint32 public latestMarket;address public staker;address public tokenFactory;uint256[45] private __globalStateGap;mapping(uint32 => bool) public marketExists;mapping(uint32 => uint256) public assetPrice;mapping(uint32 => uint256) public marketUpdateIndex;mapping(uint32 => address) public paymentTokens;mapping(uint32 => address) public yieldManagers;mapping(uint32 => address) public oracleManagers;mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;mapping(uint32 => mapping(bool => address)) public syntheticTokens;mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;mapping(uint32 => mapping(bool => mapping(address => uint256)))public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;║      EVENTS      ║╚════════════════════════════╝*/event LongShortV1(address admin, address treasury, address tokenFactory, address staker);event SystemStateUpdated(uint32 marketIndex,uint256 updateIndex,int256 underlyingAssetPrice,uint256 longValue,uint256 shortValue,uint256 longPrice,uint256 shortPrice);event SyntheticMarketCreated(uint32 marketIndex,address longTokenAddress,address shortTokenAddress,address paymentToken,uint256 initialAssetPrice,string name,string symbol,address oracleAddress,address yieldManagerAddress);event NextPriceRedeem(uint32 marketIndex,bool isLong,uint256 synthRedeemed,address user,uint256 oracleUpdateIndex);event NextPriceSyntheticPositionShift(uint32 marketIndex,bool isShiftFromLong,uint256 synthShifted,address user,uint256 oracleUpdateIndex);event NextPriceDeposit(uint32 marketIndex,bool isLong,uint256 depositAdded,address user,uint256 oracleUpdateIndex);event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);event ExecuteNextPriceMarketSideShiftSettlementUser(address user,uint32 marketIndex,bool isShiftFromLong,uint256 amount);event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);║     MODIFIERS     ║╚═════════════════════════════╝*/function adminOnlyModifierLogic() internal virtual {require(msg.sender == admin, "only admin");}modifier adminOnly() {adminOnlyModifierLogic();_;}function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {require(marketExists[marketIndex], "market doesn't exist");}modifier requireMarketExists(uint32 marketIndex) {requireMarketExistsModifierLogic(marketIndex);_;}modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {_executeOutstandingNextPriceSettlements(user, marketIndex);_;}modifier updateSystemStateMarket(uint32 marketIndex) {_updateSystemStateInternal(marketIndex);_;}║    CONTRACT SET-UP    ║╚═════════════════════════════╝*/function initialize(address _admin,address _treasury,address _tokenFactory,address _staker) external virtual initializer {admin = _admin;treasury = _treasury;tokenFactory = _tokenFactory;staker = _staker;emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);}║    ADMIN    ║╚═══════════════════╝*/function changeAdmin(address _admin) external adminOnly {admin = _admin;}function changeTreasury(address _treasury) external adminOnly {treasury = _treasury;}function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {address previousOracleManager = oracleManagers[marketIndex];oracleManagers[marketIndex] = _newOracleManager;emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);}function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)externaladminOnly{marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;}║    MARKET CREATION    ║╚═════════════════════════════╝*/function createNewSyntheticMarket(string calldata syntheticName,string calldata syntheticSymbol,address _paymentToken,address _oracleManager,address _yieldManager) external adminOnly {latestMarket++;syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(string(abi.encodePacked("Float Up ", syntheticName)),string(abi.encodePacked("fu", syntheticSymbol)),staker,latestMarket,true);syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(string(abi.encodePacked("Float Down ", syntheticName)),string(abi.encodePacked("fd", syntheticSymbol)),staker,latestMarket,false);paymentTokens[latestMarket] = _paymentToken;yieldManagers[latestMarket] = _yieldManager;oracleManagers[latestMarket] = _oracleManager;assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());emit SyntheticMarketCreated(latestMarket,syntheticTokens[latestMarket][true],syntheticTokens[latestMarket][false],_paymentToken,assetPrice[latestMarket],syntheticName,syntheticSymbol,_oracleManager,_yieldManager);}function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {require(initialMarketSeedForEachMarketSide >= 1e18,"Insufficient market seed");uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;_transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);}function initializeMarket(uint32 marketIndex,uint256 kInitialMultiplier,uint256 kPeriod,uint256 unstakeFee_e18,uint256 initialMarketSeedForEachMarketSide,uint256 balanceIncentiveCurve_exponent,int256 balanceIncentiveCurve_equilibriumOffset,uint256 _marketTreasurySplitGradient_e18) external adminOnly {require(!marketExists[marketIndex], "already initialized");require(marketIndex <= latestMarket, "index too high");marketExists[marketIndex] = true;marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;marketUpdateIndex[marketIndex] = 1;IStaker(staker).addNewStakingFund(latestMarket,syntheticTokens[latestMarket][true],syntheticTokens[latestMarket][false],kInitialMultiplier,kPeriod,unstakeFee_e18,balanceIncentiveCurve_exponent,balanceIncentiveCurve_equilibriumOffset);_seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);}║    GETTER FUNCTIONS    ║╚══════════════════════════════╝*/function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {if (a > b) {return b;} else {return a;}}function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)internalpurevirtualreturns (uint256 syntheticTokenPrice){return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;}function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)internalpurevirtualreturns (uint256 amountPaymentToken){return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;}function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)internalpurevirtualreturns (uint256 amountSyntheticToken){return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;}@notice Calculate the amount of target side synthetic tokens that are worth the sameamount of payment tokens as X many synthetic tokens on origin side.The resulting equation comes from simplifying this function_getAmountSyntheticToken(_getAmountPaymentToken(amountOriginSynth,priceOriginSynth),priceTargetSynth)Unpacking the function we get:((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynthAnd simplifying this we get:(amountOriginSynth * priceOriginSynth) / priceTargetSynth@param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side@param syntheticTokenPrice_originSide Price of origin side's synthetic token@param syntheticTokenPrice_targetSide Price of target side's synthetic token@return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target sidefunction _getEquivalentAmountSyntheticTokensOnTargetSide(uint256 amountSyntheticTokens_originSide,uint256 syntheticTokenPrice_originSide,uint256 syntheticTokenPrice_targetSide) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {equivalentAmountSyntheticTokensOnTargetSide =(amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /syntheticTokenPrice_targetSide;}function getAmountSyntheticTokenToMintOnTargetSide(uint32 marketIndex,uint256 amountSyntheticToken_redeemOnOriginSide,bool isShiftFromLong,uint256 priceSnapshotIndex) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][priceSnapshotIndex];uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][priceSnapshotIndex];amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(amountSyntheticToken_redeemOnOriginSide,syntheticTokenPriceOnOriginSide,syntheticTokenPriceOnTargetSide);}@notice The amount of a synth token a user is owed following a batch execution.4 possible states for next price actions:- "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.- "Confirmed" - means the next price has been updated by the updateSystemState function. There is still-        outstanding (lazy) computation that needs to be executed per user in the batch.- "Settled" - there is no more computation left for the user.- "Non-existant" - user has no next price actions.This function returns a calculated value only in the case of 'confirmed' next price actions.It should return zero for all other types of next price actions.@dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.@param user The address of the user for whom to execute the function for.@param marketIndex An int32 which uniquely identifies a market.@param isLong Whether it is for the long synthetic asset or the short synthetic asset.@return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.function getUsersConfirmedButNotSettledSynthBalance(address user,uint32 marketIndex,bool isLong) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];if (userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex) {uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];if (amountPaymentTokenDeposited > 0) {uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);}uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide= userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][currentMarketUpdateIndex];uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(amountSyntheticTokensToBeShiftedAwayFromOriginSide,syntheticTokenPriceOnOriginSide,syntheticTokenPriceOnTargetSide);}}}@notice Calculates the percentage in base 1e18 of how much of the accrued yieldfor a market should be allocated to treasury.@dev For gas considerations also returns whether the long side is imbalanced.@dev For gas considerations totalValueLockedInMarket is passed as a parameter as the functioncalling this function has pre calculated the value@param longValue The current total payment token value of the long side of the market.@param shortValue The current total payment token value of the short side of the market.@param totalValueLockedInMarket Total payment token value of both sides of the market.@return isLongSideUnderbalanced Whether the long side initially had less value than the short side.@return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yieldfor a market should be allocated to treasury.function _getYieldSplit(uint32 marketIndex,uint256 longValue,uint256 shortValue,uint256 totalValueLockedInMarket) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {isLongSideUnderbalanced = longValue < shortValue;uint256 imbalance;if (isLongSideUnderbalanced) {imbalance = shortValue - longValue;} else {imbalance = longValue - shortValue;}uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /totalValueLockedInMarket;uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;}║    HELPER FUNCTIONS    ║╚══════════════════════════════╝*/function _claimAndDistributeYieldThenRebalanceMarket(uint32 marketIndex,int256 newAssetPrice,int256 oldAssetPrice) internal virtual returns (uint256 longValue, uint256 shortValue) {longValue = marketSideValueInPaymentToken[marketIndex][true];shortValue = marketSideValueInPaymentToken[marketIndex][false];uint256 totalValueLockedInMarket = longValue + shortValue;(bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(marketIndex,longValue,shortValue,totalValueLockedInMarket);uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]).distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);if (marketAmount > 0) {if (isLongSideUnderbalanced) {longValue += marketAmount;} else {shortValue += marketAmount;}}int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;if (valueChange > 0) {longValue += uint256(valueChange);shortValue -= uint256(valueChange);} else {longValue -= uint256(-valueChange);shortValue += uint256(-valueChange);}}║   UPDATING SYSTEM STATE   ║╚═══════════════════════════════╝*/function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();int256 oldAssetPrice = int256(assetPrice[marketIndex]);bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;if (assetPriceHasChanged || msg.sender == staker) {uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][marketUpdateIndex[marketIndex]];uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][marketUpdateIndex[marketIndex]];if (userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&assetPriceHasChanged) {IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(marketIndex,syntheticTokenPrice_inPaymentTokens_long,syntheticTokenPrice_inPaymentTokens_short,marketSideValueInPaymentToken[marketIndex][true],marketSideValueInPaymentToken[marketIndex][false],userNextPrice_currentUpdateIndex[marketIndex][staker]);} else {IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(marketIndex,syntheticTokenPrice_inPaymentTokens_long,syntheticTokenPrice_inPaymentTokens_short,marketSideValueInPaymentToken[marketIndex][true],marketSideValueInPaymentToken[marketIndex][false],0);}if (!assetPriceHasChanged) {return;}(uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(marketIndex,newAssetPrice,oldAssetPrice);syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(newLongPoolValue,ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply());syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(newShortPoolValue,ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply());assetPrice[marketIndex] = uint256(newAssetPrice);marketUpdateIndex[marketIndex] += 1;syntheticToken_priceSnapshot[marketIndex][true][marketUpdateIndex[marketIndex]] = syntheticTokenPrice_inPaymentTokens_long;syntheticToken_priceSnapshot[marketIndex][false][marketUpdateIndex[marketIndex]] = syntheticTokenPrice_inPaymentTokens_short;(int256 long_changeInMarketValue_inPaymentToken,int256 short_changeInMarketValue_inPaymentToken) = _batchConfirmOutstandingPendingActions(marketIndex,syntheticTokenPrice_inPaymentTokens_long,syntheticTokenPrice_inPaymentTokens_short);newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;emit SystemStateUpdated(marketIndex,marketUpdateIndex[marketIndex],newAssetPrice,newLongPoolValue,newShortPoolValue,syntheticTokenPrice_inPaymentTokens_long,syntheticTokenPrice_inPaymentTokens_short);}}function updateSystemState(uint32 marketIndex) external override {_updateSystemStateInternal(marketIndex);}function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {for (uint256 i = 0; i < marketIndexes.length; i++) {_updateSystemStateInternal(marketIndexes[i]);}}║      DEPOSIT       ║╚════════════════════════════════╝*/function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));}║    MINT POSITION    ║╚═══════════════════════════╝*/function _mintNextPrice(uint32 marketIndex,uint256 amount,bool isLong)internalvirtualupdateSystemStateMarket(marketIndex)executeOutstandingNextPriceSettlements(msg.sender, marketIndex){_transferPaymentTokensFromUserToYieldManager(marketIndex, amount);batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);}function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {_mintNextPrice(marketIndex, amount, true);}function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {_mintNextPrice(marketIndex, amount, false);}║   REDEEM POSITION   ║╚═══════════════════════════╝*/function _redeemNextPrice(uint32 marketIndex,uint256 tokens_redeem,bool isLong)internalvirtualupdateSystemStateMarket(marketIndex)executeOutstandingNextPriceSettlements(msg.sender, marketIndex){require(ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem));userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);}function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {_redeemNextPrice(marketIndex, tokens_redeem, true);}function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {_redeemNextPrice(marketIndex, tokens_redeem, false);}║    SHIFT POSITION   ║╚═══════════════════════════╝*/function _shiftPositionNextPrice(uint32 marketIndex,uint256 amountSyntheticTokensToShift,bool isShiftFromLong)internalvirtualupdateSystemStateMarket(marketIndex)executeOutstandingNextPriceSettlements(msg.sender, marketIndex){require(ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(msg.sender,address(this),amountSyntheticTokensToShift));userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][msg.sender] += amountSyntheticTokensToShift;userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong] += amountSyntheticTokensToShift;emit NextPriceSyntheticPositionShift(marketIndex,isShiftFromLong,amountSyntheticTokensToShift,msg.sender,marketUpdateIndex[marketIndex] + 1);}function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {_shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);}function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {_shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);}║   NEXT PRICE SETTLEMENTS   ║╚════════════════════════════════╝*/function _executeOutstandingNextPriceMints(uint32 marketIndex,address user,bool isLong) internal virtual {uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];if (currentPaymentTokenDepositAmount > 0) {userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(currentPaymentTokenDepositAmount,syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]);require(ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser));emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);}}function _executeOutstandingNextPriceRedeems(uint32 marketIndex,address user,bool isLong) internal virtual {uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];if (currentSyntheticTokenRedemptions > 0) {userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(currentSyntheticTokenRedemptions,syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]);IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);}}function _executeOutstandingNextPriceTokenShifts(uint32 marketIndex,address user,bool isShiftFromLong) internal virtual {uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user];if (syntheticToken_toShiftAwayFrom_marketSide > 0) {uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(marketIndex,syntheticToken_toShiftAwayFrom_marketSide,isShiftFromLong,userNextPrice_currentUpdateIndex[marketIndex][user]);userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;require(ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(user,syntheticToken_toShiftTowardsTargetSide));emit ExecuteNextPriceMarketSideShiftSettlementUser(user,marketIndex,isShiftFromLong,syntheticToken_toShiftTowardsTargetSide);}}function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {_executeOutstandingNextPriceMints(marketIndex, user, true);_executeOutstandingNextPriceMints(marketIndex, user, false);_executeOutstandingNextPriceRedeems(marketIndex, user, true);_executeOutstandingNextPriceRedeems(marketIndex, user, false);_executeOutstandingNextPriceTokenShifts(marketIndex, user, true);_executeOutstandingNextPriceTokenShifts(marketIndex, user, false);userNextPrice_currentUpdateIndex[marketIndex][user] = 0;emit ExecuteNextPriceSettlementsUser(user, marketIndex);}}function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {_executeOutstandingNextPriceSettlements(user, marketIndex);}function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {for (uint256 i = 0; i < marketIndexes.length; i++) {_executeOutstandingNextPriceSettlements(user, marketIndexes[i]);}}║  BATCHED NEXT PRICE SETTLEMENT ACTIONS  ║╚═══════════════════════════════════════════╝*/function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(uint32 marketIndex,int256 totalPaymentTokenValueChangeForMarket) internal virtual {if (totalPaymentTokenValueChangeForMarket > 0) {IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));} else if (totalPaymentTokenValueChangeForMarket < 0) {IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(uint256(-totalPaymentTokenValueChangeForMarket));}}function _handleChangeInSyntheticTokensTotalSupply(uint32 marketIndex,bool isLong,int256 changeInSyntheticTokensTotalSupply) internal virtual {if (changeInSyntheticTokensTotalSupply > 0) {ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(address(this),uint256(changeInSyntheticTokensTotalSupply));} else if (changeInSyntheticTokensTotalSupply < 0) {ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));}}@notice Performs all batched next price actions on an oracle price update.@dev Mints or burns all synthetic tokens for this contract.After this function is executed all user actions in that batch are confirmed and can be settled individually bycalling _executeOutstandingNexPriceSettlements for a given user.The maths here is safe from rounding errors since it always over estimates on the batch with division.(as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)@param marketIndex An int32 which uniquely identifies a market.@param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.@param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.@return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.@return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.function _batchConfirmOutstandingPendingActions(uint32 marketIndex,uint256 syntheticTokenPrice_inPaymentTokens_long,uint256 syntheticTokenPrice_inPaymentTokens_short)internalvirtualreturns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken){int256 changeInSupply_syntheticToken_long;int256 changeInSupply_syntheticToken_short;uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];if (amountForCurrentAction_workingVariable > 0) {long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);batched_amountPaymentToken_deposit[marketIndex][true] = 0;changeInSupply_syntheticToken_long = int256(_getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long));}amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];if (amountForCurrentAction_workingVariable > 0) {short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);batched_amountPaymentToken_deposit[marketIndex][false] = 0;changeInSupply_syntheticToken_short = int256(_getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short));}amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];if (amountForCurrentAction_workingVariable > 0) {int256 paymentTokenValueChangeForShiftToShort = int256(_getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long));long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);changeInSupply_syntheticToken_short += int256(_getEquivalentAmountSyntheticTokensOnTargetSide(amountForCurrentAction_workingVariable,syntheticTokenPrice_inPaymentTokens_long,syntheticTokenPrice_inPaymentTokens_short));batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;}amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];if (amountForCurrentAction_workingVariable > 0) {int256 paymentTokenValueChangeForShiftToLong = int256(_getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short));short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);changeInSupply_syntheticToken_long += int256(_getEquivalentAmountSyntheticTokensOnTargetSide(amountForCurrentAction_workingVariable,syntheticTokenPrice_inPaymentTokens_short,syntheticTokenPrice_inPaymentTokens_long));batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;}amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];if (amountForCurrentAction_workingVariable > 0) {long_changeInMarketValue_inPaymentToken -= int256(_getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long));changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);batched_amountSyntheticToken_redeem[marketIndex][true] = 0;}amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];if (amountForCurrentAction_workingVariable > 0) {short_changeInMarketValue_inPaymentToken -= int256(_getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short));changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);batched_amountSyntheticToken_redeem[marketIndex][false] = 0;}_handleTotalPaymentTokenValueChangeForMarketWithYieldManager(marketIndex,long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken);_handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);_handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);}}