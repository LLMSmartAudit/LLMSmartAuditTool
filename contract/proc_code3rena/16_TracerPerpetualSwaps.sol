pragma solidity ^0.8.0;import "./lib/SafetyWithdraw.sol";import "./lib/LibMath.sol";import {Balances} from "./lib/LibBalances.sol";import {Types} from "./Interfaces/Types.sol";import "./lib/LibPrices.sol";import "./lib/LibPerpetuals.sol";import "./Interfaces/IOracle.sol";import "./Interfaces/IInsurance.sol";import "./Interfaces/ITracerPerpetualSwaps.sol";import "./Interfaces/IPricing.sol";import "./Interfaces/ITrader.sol";import "@openzeppelin/contracts/access/Ownable.sol";import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "prb-math/contracts/PRBMathSD59x18.sol";import "prb-math/contracts/PRBMathUD60x18.sol";contract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {using LibMath for uint256;using LibMath for int256;using PRBMathSD59x18 for int256;using PRBMathUD60x18 for uint256;uint256 public constant override LIQUIDATION_GAS_COST = 63516;address public immutable override tracerQuoteToken;uint256 public immutable override quoteTokenDecimals;bytes32 public immutable override marketId;IPricing public pricingContract;IInsurance public insuranceContract;address public override liquidationContract;uint256 public override feeRate;uint256 public override fees;address public override feeReceiver;address public override gasPriceOracle;uint256 public override maxLeverage;uint256 public override fundingRateSensitivity;uint256 public override deleveragingCliff;funding rate changes, and lowestMaxLeverage is reached */uint256 public override insurancePoolSwitchStage;uint256 public override lowestMaxLeverage;mapping(address => Balances.Account) public balances;uint256 public tvl;uint256 public override leveragedNotionalValue;mapping(address => bool) public override tradingWhitelist;event FeeReceiverUpdated(address indexed receiver);event FeeWithdrawn(address indexed receiver, uint256 feeAmount);event Deposit(address indexed user, uint256 indexed amount);event Withdraw(address indexed user, uint256 indexed amount);event Settled(address indexed account, int256 margin);event MatchedOrders(address indexed long,address indexed short,uint256 amount,uint256 price,bytes32 longOrderId,bytes32 shortOrderId);event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);constructor(bytes32 _marketId,address _tracerQuoteToken,uint256 _tokenDecimals,address _gasPriceOracle,uint256 _maxLeverage,uint256 _fundingRateSensitivity,uint256 _feeRate,address _feeReceiver,uint256 _deleveragingCliff,uint256 _lowestMaxLeverage,uint256 _insurancePoolSwitchStage) Ownable() {tracerQuoteToken = _tracerQuoteToken;quoteTokenDecimals = _tokenDecimals;gasPriceOracle = _gasPriceOracle;marketId = _marketId;feeRate = _feeRate;maxLeverage = _maxLeverage;fundingRateSensitivity = _fundingRateSensitivity;feeReceiver = _feeReceiver;deleveragingCliff = _deleveragingCliff;lowestMaxLeverage = _lowestMaxLeverage;insurancePoolSwitchStage = _insurancePoolSwitchStage;}function trueMaxLeverage() public view override returns (uint256) {IInsurance insurance = IInsurance(insuranceContract);returnPerpetuals.calculateTrueMaxLeverage(insurance.getPoolHoldings(),insurance.getPoolTarget(),maxLeverage,lowestMaxLeverage,deleveragingCliff,insurancePoolSwitchStage);}function deposit(uint256 amount) external override {Balances.Account storage userBalance = balances[msg.sender];settle(msg.sender);uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);userBalance.position.quote = userBalance.position.quote + convertedWadAmount;_updateAccountLeverage(msg.sender);tvl = tvl + uint256(convertedWadAmount);emit Deposit(msg.sender, amount);}function withdraw(uint256 amount) external override {settle(msg.sender);uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);Balances.Account storage userBalance = balances[msg.sender];int256 newQuote = userBalance.position.quote - convertedWadAmount;Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);require(Balances.marginIsValid(newPosition,userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,pricingContract.fairPrice(),trueMaxLeverage()),"TCR: Withdraw below valid Margin");userBalance.position.quote = newQuote;_updateAccountLeverage(msg.sender);tvl = tvl - amount;IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);emit Withdraw(msg.sender, uint256(convertedWadAmount));}function matchOrders(Perpetuals.Order memory order1,Perpetuals.Order memory order2,uint256 fillAmount) external override onlyWhitelisted returns (bool) {bytes32 order1Id = Perpetuals.orderId(order1);bytes32 order2Id = Perpetuals.orderId(order2);uint256 filled1 = ITrader(msg.sender).filled(order1Id);uint256 filled2 = ITrader(msg.sender).filled(order2Id);uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);settle(order1.maker);settle(order2.maker);(Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(order1,order2,fillAmount,executionPrice);if (!Perpetuals.canMatch(order1, filled1, order2, filled2) ||!Balances.marginIsValid(newPos1,balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,pricingContract.fairPrice(),trueMaxLeverage()) ||!Balances.marginIsValid(newPos2,balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,pricingContract.fairPrice(),trueMaxLeverage())) {if (order1.side == Perpetuals.Side.Long) {emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);} else {emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);}return false;}balances[order1.maker].position = newPos1;balances[order2.maker].position = newPos2;fees =fees +uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);_updateAccountLeverage(order1.maker);_updateAccountLeverage(order2.maker);pricingContract.recordTrade(executionPrice);if (order1.side == Perpetuals.Side.Long) {emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);} else {emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);}return true;}function _executeTrade(Perpetuals.Order memory order1,Perpetuals.Order memory order2,uint256 fillAmount,uint256 executionPrice) internal view returns (Balances.Position memory, Balances.Position memory) {Balances.Account memory account1 = balances[order1.maker];Balances.Account memory account2 = balances[order2.maker];(Balances.Trade memory trade1, Balances.Trade memory trade2) = (Balances.Trade(executionPrice, fillAmount, order1.side),Balances.Trade(executionPrice, fillAmount, order2.side));(Balances.Position memory newPos1, Balances.Position memory newPos2) = (Balances.applyTrade(account1.position, trade1, feeRate),Balances.applyTrade(account2.position, trade2, feeRate));return (newPos1, newPos2);}function _updateAccountLeverage(address account) internal {Balances.Account memory userBalance = balances[account];uint256 originalLeverage = userBalance.totalLeveragedValue;uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());balances[account].totalLeveragedValue = newLeverage;_updateTracerLeverage(newLeverage, originalLeverage);}function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {leveragedNotionalValue = Prices.globalLeverage(leveragedNotionalValue,accountOldLeveragedNotional,accountNewLeveragedNotional);}function updateAccountsOnLiquidation(address liquidator,address liquidatee,int256 liquidatorQuoteChange,int256 liquidatorBaseChange,int256 liquidateeQuoteChange,int256 liquidateeBaseChange,uint256 amountToEscrow) external override onlyLiquidation {uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();Balances.Account storage liquidatorBalance = balances[liquidator];Balances.Account storage liquidateeBalance = balances[liquidatee];liquidatorBalance.lastUpdatedGasPrice = gasPrice;liquidatorBalance.position.quote =liquidatorBalance.position.quote +liquidatorQuoteChange -amountToEscrow.toInt256();liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;require(userMarginIsValid(liquidator), "TCR: Liquidator under min margin");}Liquidation.sol needs to tell the market to update its balance and the balance of theliquidated agent.in order to cover liquidationfunction updateAccountsOnClaim(address claimant,int256 amountToGiveToClaimant,address liquidatee,int256 amountToGiveToLiquidatee,int256 amountToTakeFromInsurance) external override onlyLiquidation {address insuranceAddr = address(insuranceContract);balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;require(balances[insuranceAddr].position.quote >= 0, "TCR: Insurance not funded enough");}function settle(address account) public override {uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();Balances.Account storage accountBalance = balances[account];if (accountBalance.position.base == 0) {accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();} else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(lastEstablishedIndex);Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(accountLastUpdatedIndex);Balances.Account storage insuranceBalance = balances[address(insuranceContract)];accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();if (accountBalance.totalLeveragedValue > 0) {(Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(accountBalance.position,insuranceBalance.position,currInsuranceGlobalRate,currInsuranceUserRate,accountBalance.totalLeveragedValue);balances[account].position = newUserPos;balances[(address(insuranceContract))].position = newInsurancePos;}accountBalance.lastUpdatedIndex = lastEstablishedIndex;require(userMarginIsValid(account), "TCR: Target under-margined");emit Settled(account, accountBalance.position.quote);}}function userMarginIsValid(address account) public view returns (bool) {Balances.Account memory accountBalance = balances[account];returnBalances.marginIsValid(accountBalance.position,accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,pricingContract.fairPrice(),trueMaxLeverage());}function withdrawFees() external override {uint256 tempFees = fees;fees = 0;tvl = tvl - tempFees;IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);emit FeeWithdrawn(feeReceiver, tempFees);}function getBalance(address account) external view override returns (Balances.Account memory) {return balances[account];}function setLiquidationContract(address _liquidationContract) external override onlyOwner {require(_liquidationContract != address(0), "address(0) given");liquidationContract = _liquidationContract;}function setInsuranceContract(address insurance) external override onlyOwner {require(insurance != address(0), "address(0) given");insuranceContract = IInsurance(insurance);}function setPricingContract(address pricing) external override onlyOwner {require(pricing != address(0), "address(0) given");pricingContract = IPricing(pricing);}function setGasOracle(address _gasOracle) external override onlyOwner {require(_gasOracle != address(0), "address(0) given");gasPriceOracle = _gasOracle;}function setFeeReceiver(address _feeReceiver) external override onlyOwner {require(_feeReceiver != address(0), "address(0) given");feeReceiver = _feeReceiver;emit FeeReceiverUpdated(_feeReceiver);}function setFeeRate(uint256 _feeRate) external override onlyOwner {feeRate = _feeRate;}function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {maxLeverage = _maxLeverage;}function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {fundingRateSensitivity = _fundingRateSensitivity;}function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {deleveragingCliff = _deleveragingCliff;}function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {lowestMaxLeverage = _lowestMaxLeverage;}function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {insurancePoolSwitchStage = _insurancePoolSwitchStage;}function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {require(newOwner != address(0), "address(0) given");super.transferOwnership(newOwner);}function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {tradingWhitelist[tradingContract] = whitelisted;}modifier onlyLiquidation() {require(msg.sender == liquidationContract, "TCR: Sender not liquidation");_;}modifier onlyWhitelisted() {require(tradingWhitelist[msg.sender], "TCR: Contract not whitelisted");_;}}