pragma solidity ^0.8.0;import "./LockeERC20.sol";import "solmate/utils/SafeTransferLib.sol";import "solmate/tokens/ERC20.sol";contract Governed {address public gov;address private pendingGov;address public emergency_gov;event NewGov(address indexed oldGov, address indexed newGov);event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);constructor(address _governor, address _emergency_governor) public {gov = _governor;emergency_gov = _emergency_governor;}function governorship() public view returns (address, address, address) {return (gov, emergency_gov, pendingGov);}function setPendingGov(address newPendingGov) governed public {address old = pendingGov;pendingGov = newPendingGov;emit NewPendingGov(old, newPendingGov);}function acceptGov() public {require(pendingGov == msg.sender, "!pending");address old = gov;gov = pendingGov;emit NewGov(old, pendingGov);}function setEmergencyGov(address who) public governed {emergency_gov = who;}function __abdicate() governed public {address old = gov;gov = address(0);emit NewGov(old, address(0));}modifier governed {require(msg.sender == gov, "!gov");_;}modifier emergency_governed {require(msg.sender == gov || msg.sender == emergency_gov, "!egov");_;}}interface IGoverned {function gov() external view returns (address);function emergency_gov() external view returns (address);}abstract contract ExternallyGoverned {IGoverned public gov;constructor(address governor) {gov = IGoverned(governor);}modifier externallyGoverned {require(msg.sender == gov.gov(), "!gov");_;}modifier externallyEmergencyGoverned {require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), "!e_gov");_;}}interface LockeCallee {function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;}contract Stream is LockeERC20, ExternallyGoverned {using SafeTransferLib for ERC20;struct TokenStream {uint256 lastCumulativeRewardPerToken;uint256 virtualBalance;uint112 rewards;uint112 tokens;uint32 lastUpdate;bool merkleAccess;}uint32 private immutable startTime;uint32 private immutable streamDuration;uint32 private immutable depositLockDuration;uint32 private immutable rewardLockDuration;uint32 private immutable endStream;uint32 private immutable endDepositLock;uint32 private immutable endRewardLock;address public immutable rewardToken;address public immutable depositToken;uint64 public immutable streamId;uint16 private immutable feePercent;bool private immutable feeEnabled;bool public immutable isSale;address public immutable streamCreator;uint112 private immutable depositDecimalsOne;uint112 private rewardTokenAmount;uint112 private depositTokenAmount;uint112 private rewardTokenFeeAmount;uint112 private depositTokenFlashloanFeeAmount;uint8 private unlocked = 1;bool private claimedDepositTokens;uint256 private cumulativeRewardPerToken;uint256 private totalVirtualBalance;uint112 public unstreamed;uint112 private redeemedDepositTokens;uint32 private lastUpdate;mapping (address => TokenStream) public tokensNotYetStreamed;mapping (address => uint112) public incentives;event StreamFunded(uint256 amount);event Staked(address indexed who, uint256 amount);event Withdrawn(address indexed who, uint256 amount);event StreamIncentivized(address indexed token, uint256 amount);event StreamIncentiveClaimed(address indexed token, uint256 amount);event SoldTokensClaimed(address indexed who, uint256 amount);event DepositTokensReclaimed(address indexed who, uint256 amount);event FeesClaimed(address indexed token, address indexed who, uint256 amount);event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);event RewardsClaimed(address indexed who, uint256 amount);event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);modifier updateStream(address who) {updateStreamInternal(who);_;}function updateStreamInternal(address who) internal {require(block.timestamp < endStream , "!stream");TokenStream storage ts = tokensNotYetStreamed[msg.sender];if (block.timestamp >= startTime) {if (ts.lastUpdate == 0) {ts.lastUpdate = uint32(block.timestamp);}if (lastUpdate == 0) {lastUpdate = uint32(block.timestamp);}cumulativeRewardPerToken = rewardPerToken();ts.rewards = earned(ts, cumulativeRewardPerToken);ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;if (acctTimeDelta > 0 && ts.tokens > 0) {ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));ts.lastUpdate = uint32(block.timestamp);}uint32 tdelta = uint32(block.timestamp - lastUpdate);if (tdelta > 0 && unstreamed > 0) {uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);}lastUpdate = uint32(block.timestamp);} else {if (ts.lastUpdate == 0) {ts.lastUpdate = startTime;}if (lastUpdate == 0) {lastUpdate = startTime;}}}function lockInternal() internal {require(unlocked == 1, "re");unlocked = 2;}modifier lock {lockInternal();_;unlocked = 1;}constructor(uint64 _streamId,address creator,bool _isSale,address _rewardToken,address _depositToken,uint32 _startTime,uint32 _streamDuration,uint32 _depositLockDuration,uint32 _rewardLockDuration,uint16 _feePercent,bool _feeEnabled)LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)ExternallyGoverned(msg.sender)public{feePercent = _feePercent;feeEnabled = _feeEnabled;require(feePercent < 10000, "fee");startTime = _startTime;streamDuration = _streamDuration;depositLockDuration = _depositLockDuration;rewardLockDuration = _rewardLockDuration;endStream = startTime + streamDuration;endDepositLock = endStream + depositLockDuration;endRewardLock = endStream + rewardLockDuration;depositToken = _depositToken;rewardToken = _rewardToken;streamId = _streamId;isSale = _isSale;streamCreator = creator;depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());}function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);}function feeParams() public view returns (uint16, bool) {return (feePercent, feeEnabled);}function streamParams() public view returns (uint32,uint32,uint32,uint32) {return (startTime,streamDuration,depositLockDuration,rewardLockDuration);}function lastApplicableTime() internal view returns (uint32) {return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;}function rewardPerToken() public view returns (uint256) {if (totalVirtualBalance == 0) {return cumulativeRewardPerToken;} else {return cumulativeRewardPerToken + (((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration)/ totalVirtualBalance);}}function dilutedBalance(uint112 amount) internal view returns (uint256) {if (block.timestamp < startTime) {return amount;} else {uint32 timeRemaining = endStream - uint32(block.timestamp);return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;}}function getEarned(address who) public view returns (uint256) {TokenStream storage ts = tokensNotYetStreamed[who];return earned(ts, rewardPerToken());}function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;}function fundStream(uint112 amount) public lock {require(amount > 0, "amt");require(block.timestamp < startTime, "time");uint112 amt;uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);uint256 newBal = ERC20(rewardToken).balanceOf(address(this));require(newBal < type(uint112).max && newBal > prevBal, "erc");amount = uint112(newBal - prevBal);if (feeEnabled) {uint112 feeAmt;unchecked {feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000);amt = amount - feeAmt;}rewardTokenFeeAmount += feeAmt;rewardTokenAmount += amt;} else {amt = amount;rewardTokenAmount += amt;}emit StreamFunded(amt);}function stake(uint112 amount) public lock updateStream(msg.sender) {require(amount > 0, "amt");uint256 prevBal = ERC20(depositToken).balanceOf(address(this));ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);uint256 newBal = ERC20(depositToken).balanceOf(address(this));require(newBal <= type(uint112).max && newBal > prevBal, "erc");uint112 trueDepositAmt = uint112(newBal - prevBal);depositTokenAmount += trueDepositAmt;TokenStream storage ts = tokensNotYetStreamed[msg.sender];ts.tokens += trueDepositAmt;uint256 virtualBal = dilutedBalance(trueDepositAmt);ts.virtualBalance += virtualBal;totalVirtualBalance += virtualBal;unstreamed += trueDepositAmt;if (!isSale) {_mint(msg.sender, trueDepositAmt);} else {}emit Staked(msg.sender, trueDepositAmt);}function withdraw(uint112 amount) public lock updateStream(msg.sender) {require(amount > 0, "amt");TokenStream storage ts = tokensNotYetStreamed[msg.sender];require(ts.tokens >= amount, "amt");ts.tokens -= amount;uint256 virtualBal = dilutedBalance(amount);ts.virtualBalance -= virtualBal;totalVirtualBalance -= virtualBal;depositTokenAmount -= amount;if (!isSale) {_burn(msg.sender, amount);} else {}ERC20(depositToken).safeTransfer(msg.sender, amount);emit Withdrawn(msg.sender, amount);}function exit() public updateStream(msg.sender) {TokenStream storage ts = tokensNotYetStreamed[msg.sender];uint112 amount = ts.tokens;withdraw(amount);}function createIncentive(address token, uint112 amount) public lock {require(token != rewardToken && token != depositToken, "inc");uint256 prevBal = ERC20(token).balanceOf(address(this));ERC20(token).safeTransferFrom(msg.sender, address(this), amount);uint256 newBal = ERC20(token).balanceOf(address(this));require(newBal <= type(uint112).max && newBal > prevBal, "erc");uint112 amt = uint112(newBal - prevBal);incentives[token] += amt;emit StreamIncentivized(token, amt);}function claimIncentive(address token) public lock {require(msg.sender == streamCreator, "!creator");require(block.timestamp >= endStream, "stream");uint112 amount = incentives[token];require(amount > 0, "amt");incentives[token] = 0;ERC20(token).safeTransfer(msg.sender, amount);emit StreamIncentiveClaimed(token, amount);}function claimDepositTokens(uint112 amount) public lock {require(!isSale, "sale");require(amount > 0, "amt");require(block.timestamp > endDepositLock, "lock");_burn(msg.sender, amount);redeemedDepositTokens += amount;ERC20(depositToken).safeTransfer(msg.sender, amount);emit DepositTokensReclaimed(msg.sender, amount);}function claimReward() public lock {require(block.timestamp > endRewardLock, "lock");TokenStream storage ts = tokensNotYetStreamed[msg.sender];cumulativeRewardPerToken = rewardPerToken();ts.rewards = earned(ts, cumulativeRewardPerToken);ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;lastUpdate = lastApplicableTime();uint256 rewardAmt = ts.rewards;ts.rewards = 0;require(rewardAmt > 0, "amt");ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);emit RewardsClaimed(msg.sender, rewardAmt);}function creatorClaimSoldTokens(address destination) public lock {require(isSale, "!sale");require(!claimedDepositTokens, "claimed");require(msg.sender == streamCreator, "!creator");require(block.timestamp >= endStream, "stream");uint112 amount = depositTokenAmount;claimedDepositTokens = true;ERC20(depositToken).safeTransfer(destination, amount);emit SoldTokensClaimed(destination, amount);}function claimFees(address destination) public lock externallyGoverned {require(block.timestamp >= endStream, "stream");uint112 fees = rewardTokenFeeAmount;if (fees > 0) {rewardTokenFeeAmount = 0;ERC20(rewardToken).safeTransfer(destination, fees);emit FeesClaimed(rewardToken, destination, fees);}fees = depositTokenFlashloanFeeAmount;if (fees > 0) {depositTokenFlashloanFeeAmount = 0;ERC20(depositToken).safeTransfer(destination, fees);emit FeesClaimed(depositToken, destination, fees);}}function recoverTokens(address token, address recipient) public lock {require(msg.sender == streamCreator, "!creator");if (token == depositToken) {require(block.timestamp > endDepositLock, "time");uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);ERC20(token).safeTransfer(recipient, excess);emit RecoveredTokens(token, recipient, excess);return;}if (token == rewardToken) {require(block.timestamp > endRewardLock, "time");uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);ERC20(token).safeTransfer(recipient, excess);emit RecoveredTokens(token, recipient, excess);return;}if (incentives[token] > 0) {require(block.timestamp >= endStream, "stream");uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];ERC20(token).safeTransfer(recipient, excess);emit RecoveredTokens(token, recipient, excess);return;}uint256 bal = ERC20(token).balanceOf(address(this));ERC20(token).safeTransfer(recipient, bal);emit RecoveredTokens(token, recipient, bal);}function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {require(token == depositToken || token == rewardToken, "erc");uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));ERC20(token).safeTransfer(to, amount);LockeCallee(to).lockeCall(msg.sender, token, amount, data);uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));uint112 feeAmt = amount * 10 / 10000;if (token == depositToken) {depositTokenFlashloanFeeAmount += feeAmt;require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, "f1");require(preRewardTokenBalance <= postRewardTokenBalance, "f2");} else {rewardTokenFeeAmount += feeAmt;require(preDepositTokenBalance <= postDepositTokenBalance, "f3");require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, "f4");}emit Flashloaned(token, msg.sender, amount, feeAmt);}function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {require(incentives[who] == 0, "inc");require(who != depositToken && who != rewardToken, "erc");uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));(bool success, bytes memory _ret) = who.call(data);require(success);uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, "erc");}}contract StreamFactory is Governed {struct GovernableStreamParams {uint32 maxDepositLockDuration;uint32 maxRewardLockDuration;uint32 maxStreamDuration;uint32 minStreamDuration;}struct GovernableFeeParams {uint16 feePercent;bool feeEnabled;}GovernableStreamParams public streamParams;GovernableFeeParams public feeParams;uint64 public currStreamId;uint16 constant MAX_FEE_PERCENT = 500;event StreamCreated(uint256 indexed stream_id, address stream_addr);event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {streamParams = GovernableStreamParams({maxDepositLockDuration: 52 weeks,maxRewardLockDuration: 52 weeks,maxStreamDuration: 2 weeks,minStreamDuration: 1 hours});}function createStream(address rewardToken,address depositToken,uint32 startTime,uint32 streamDuration,uint32 depositLockDuration,uint32 rewardLockDuration,bool isSale)publicreturns (Stream){{require(startTime >= block.timestamp, "past");require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, "stream");require(depositLockDuration <= streamParams.maxDepositLockDuration, "lock");require(rewardLockDuration <= streamParams.maxRewardLockDuration, "reward");}uint64 that_stream = currStreamId;currStreamId += 1;bytes32 salt = bytes32(uint256(that_stream));Stream stream = new Stream{salt: salt}(that_stream,msg.sender,isSale,rewardToken,depositToken,startTime,streamDuration,depositLockDuration,rewardLockDuration,feeParams.feePercent,feeParams.feeEnabled);emit StreamCreated(that_stream, address(stream));return stream;}function updateStreamParams(GovernableStreamParams memory newParams) public governed {GovernableStreamParams memory old = streamParams;streamParams = newParams;emit StreamParametersUpdated(old, newParams);}function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {require(newFeeParams.feePercent <= MAX_FEE_PERCENT, "fee");GovernableFeeParams memory old = feeParams;feeParams = newFeeParams;emit FeeParametersUpdated(old, newFeeParams);}}