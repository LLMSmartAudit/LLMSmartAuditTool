pragma solidity ^0.8.17;import "solmate/tokens/ERC20.sol";import "solmate/tokens/ERC721.sol";import "solmate/utils/MerkleProofLib.sol";import "solmate/utils/SafeTransferLib.sol";import "openzeppelin/utils/math/Math.sol";import "./LpToken.sol";import "./Caviar.sol";contract Pair is ERC20, ERC721TokenReceiver {using SafeTransferLib for address;using SafeTransferLib for ERC20;uint256 public constant ONE = 1e18;uint256 public constant CLOSE_GRACE_PERIOD = 7 days;address public immutable nft;address public immutable baseToken;bytes32 public immutable merkleRoot;LpToken public immutable lpToken;Caviar public immutable caviar;uint256 public closeTimestamp;event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);event Buy(uint256 inputAmount, uint256 outputAmount);event Sell(uint256 inputAmount, uint256 outputAmount);event Wrap(uint256[] tokenIds);event Unwrap(uint256[] tokenIds);event Close(uint256 closeTimestamp);event Withdraw(uint256 tokenId);constructor(address _nft,address _baseToken,bytes32 _merkleRoot,string memory pairSymbol,string memory nftName,string memory nftSymbol) ERC20(string.concat(nftName, " fractional token"), string.concat("f", nftSymbol), 18) {nft = _nft;baseToken = _baseToken;merkleRoot = _merkleRoot;lpToken = new LpToken(pairSymbol);caviar = Caviar(msg.sender);}function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)publicpayablereturns (uint256 lpTokenAmount){require(baseTokenAmount > 0 && fractionalTokenAmount > 0, "Input token amount is zero");require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, "Invalid ether input");lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);require(lpTokenAmount >= minLpTokenAmount, "Slippage: lp token amount out");_transferFrom(msg.sender, address(this), fractionalTokenAmount);lpToken.mint(msg.sender, lpTokenAmount);if (baseToken != address(0)) {ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);}emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);}function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)publicreturns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount){(baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);require(baseTokenOutputAmount >= minBaseTokenOutputAmount, "Slippage: base token amount out");require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, "Slippage: fractional token out");_transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);lpToken.burn(msg.sender, lpTokenAmount);if (baseToken == address(0)) {msg.sender.safeTransferETH(baseTokenOutputAmount);} else {ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);}emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);}function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, "Invalid ether input");inputAmount = buyQuote(outputAmount);require(inputAmount <= maxInputAmount, "Slippage: amount in");_transferFrom(address(this), msg.sender, outputAmount);if (baseToken == address(0)) {uint256 refundAmount = maxInputAmount - inputAmount;if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);} else {ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);}emit Buy(inputAmount, outputAmount);}function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {outputAmount = sellQuote(inputAmount);require(outputAmount >= minOutputAmount, "Slippage: amount out");_transferFrom(msg.sender, address(this), inputAmount);if (baseToken == address(0)) {msg.sender.safeTransferETH(outputAmount);} else {ERC20(baseToken).safeTransfer(msg.sender, outputAmount);}emit Sell(inputAmount, outputAmount);}function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)publicreturns (uint256 fractionalTokenAmount){require(closeTimestamp == 0, "Wrap: closed");_validateTokenIds(tokenIds, proofs);fractionalTokenAmount = tokenIds.length * ONE;_mint(msg.sender, fractionalTokenAmount);for (uint256 i = 0; i < tokenIds.length; i++) {ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);}emit Wrap(tokenIds);}function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {fractionalTokenAmount = tokenIds.length * ONE;_burn(msg.sender, fractionalTokenAmount);for (uint256 i = 0; i < tokenIds.length; i++) {ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);}emit Unwrap(tokenIds);}function nftAdd(uint256 baseTokenAmount,uint256[] calldata tokenIds,uint256 minLpTokenAmount,bytes32[][] calldata proofs) public payable returns (uint256 lpTokenAmount) {uint256 fractionalTokenAmount = wrap(tokenIds, proofs);lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);}function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)publicreturns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount){(baseTokenOutputAmount, fractionalTokenOutputAmount) =remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);unwrap(tokenIds);}function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {inputAmount = buy(tokenIds.length * ONE, maxInputAmount);unwrap(tokenIds);}function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)publicreturns (uint256 outputAmount){uint256 inputAmount = wrap(tokenIds, proofs);outputAmount = sell(inputAmount, minOutputAmount);}function close() public {require(caviar.owner() == msg.sender, "Close: not owner");closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;caviar.destroy(nft, baseToken, merkleRoot);emit Close(closeTimestamp);}function withdraw(uint256 tokenId) public {require(caviar.owner() == msg.sender, "Withdraw: not owner");require(closeTimestamp != 0, "Withdraw not initiated");require(block.timestamp >= closeTimestamp, "Not withdrawable yet");ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);emit Withdraw(tokenId);}function baseTokenReserves() public view returns (uint256) {return _baseTokenReserves();}function fractionalTokenReserves() public view returns (uint256) {return balanceOf[address(this)];}function price() public view returns (uint256) {return (_baseTokenReserves() * ONE) / fractionalTokenReserves();}function buyQuote(uint256 outputAmount) public view returns (uint256) {return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);}function sellQuote(uint256 inputAmount) public view returns (uint256) {uint256 inputAmountWithFee = inputAmount * 997;return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);}function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {uint256 lpTokenSupply = lpToken.totalSupply();if (lpTokenSupply > 0) {uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();return Math.min(baseTokenShare, fractionalTokenShare);} else {return Math.sqrt(baseTokenAmount * fractionalTokenAmount);}}function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {uint256 lpTokenSupply = lpToken.totalSupply();uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;return (baseTokenOutputAmount, fractionalTokenOutputAmount);}function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {balanceOf[from] -= amount;unchecked {balanceOf[to] += amount;}emit Transfer(from, to, amount);return true;}function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {if (merkleRoot == bytes23(0)) return;for (uint256 i = 0; i < tokenIds.length; i++) {bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));require(isValid, "Invalid merkle proof");}}function _baseTokenReserves() internal view returns (uint256) {return baseToken == address(0)? address(this).balance - msg.value: ERC20(baseToken).balanceOf(address(this));}}