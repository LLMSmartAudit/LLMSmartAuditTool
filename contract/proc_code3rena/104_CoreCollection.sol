pragma solidity ^0.8.0;import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";import {ERC721Enumerable} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";import {ERC721Payable} from "./ERC721Payable.sol";import {ERC721Claimable} from "./ERC721Claimable.sol";import {IRoyaltyVault} from "@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol";contract CoreCollection isOwnable,ERC721Claimable,ERC721Enumerable,ERC721Payable{bool public initialized;string private _name;string private _symbol;string private _baseUri;uint256 public maxSupply;uint256 public startingIndex;uint256 public startingIndexBlock;string public HASHED_PROOF = "";event ClaimInitialized(bytes32 root);event NewCollectionMeta(string name, string symbol);event NewClaim(address claimedBy, address to, uint256 tokenId);event StartingIndexSet(uint256 index);event RoyaltyVaultInitialized(address royaltyVault);event NewHashedProof(string proof);event NewWithdrawal(address to, uint256 amount);constructor() ERC721("", "") {}modifier onlyInitialized() {require(initialized, "CoreCollection: Not initialized");_;}modifier onlyUnInitialized() {require(!initialized, "CoreCollection: Already initialized");_;}modifier onlyValidSupply(uint256 _maxSupply) {require(_maxSupply > 0,"CoreCollection: Max supply should be greater than 0");_;}modifier tokenExists(uint256 _tokenId) {require(_exists(_tokenId), "CoreCollection: Invalid token id");_;}function initialize(string memory _collectionName,string memory _collectionSymbol,string memory _collectionURI,uint256 _maxSupply,uint256 _mintFee,address _payableToken,bool _isForSale,address _splitFactory) external onlyOwner onlyValidSupply(_maxSupply) {_name = _collectionName;_symbol = _collectionSymbol;_baseUri = _collectionURI;maxSupply = _maxSupply;mintFee = _mintFee;payableToken = IERC20(_payableToken);isForSale = _isForSale;splitFactory = _splitFactory;initialized = true;}function initializeClaims(bytes32 _root)externalonlyOwneronlyNotClaimableSetonlyValidRoot(_root){_setMerkelRoot(_root);emit ClaimInitialized(_root);}function setCollectionMeta(string memory _collectionName,string memory _collectionSymbol) external onlyOwner {_name = _collectionName;_symbol = _collectionSymbol;emit NewCollectionMeta(_collectionName, _collectionSymbol);}function mintToken(address to,bool isClaim,uint256 claimableAmount,uint256 amount,bytes32[] calldata merkleProof) external onlyInitialized {require(amount > 0, "CoreCollection: Amount should be greater than 0");require(totalSupply() + amount <= maxSupply,"CoreCollection: Over Max Supply");if (isClaim) {require(claimableSet(), "CoreCollection: No claimable");require(canClaim(msg.sender, claimableAmount, amount, merkleProof),"CoreCollection: Can't claim");_claim(msg.sender, amount);} else {require(isForSale, "CoreCollection: Not for sale");if (mintFee > 0) {_handlePayment(mintFee * amount);}}batchMint(to, amount, isClaim);}function withdraw() external onlyOwner {uint256 amount = payableToken.balanceOf(address(this));payableToken.transferFrom(address(this), msg.sender, amount);emit NewWithdrawal(msg.sender, amount);}function setRoyaltyVault(address _royaltyVault)externalonlyVaultUninitialized{require(msg.sender == splitFactory || msg.sender == owner(),"CoreCollection: Only Split Factory or owner can initialize vault.");royaltyVault = _royaltyVault;emit RoyaltyVaultInitialized(_royaltyVault);}function setHashedProof(string calldata _proof) external onlyOwner {require(bytes(HASHED_PROOF).length == 0,"CoreCollection: Hashed Proof is set");HASHED_PROOF = _proof;emit NewHashedProof(_proof);}function setStartingIndex() public {require(startingIndex == 0,"CoreCollection: Starting index is already set");startingIndex =(uint256(keccak256(abi.encodePacked("CoreCollection", block.number))) % maxSupply) +1;startingIndexBlock = uint256(block.number);emit StartingIndexSet(startingIndex);}function name() public view override returns (string memory) {return _name;}function symbol() public view override returns (string memory) {return _symbol;}function baseURI() public view returns (string memory) {return _baseUri;}function _baseURI() internal view override returns (string memory) {return _baseUri;}function mint(address _to) private returns (uint256 tokenId) {if (startingIndex == 0) {setStartingIndex();}tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;_mint(_to, tokenId);}function batchMint(address _to,uint256 _amount,bool _isClaim) private {for (uint256 i = 0; i < _amount; i++) {uint256 tokenId = mint(_to);if (_isClaim) {emit NewClaim(msg.sender, _to, tokenId);}}}function _beforeTokenTransfer(address _from,address _to,uint256 _tokenId) internal virtual override {super._beforeTokenTransfer(_from, _to, _tokenId);if (royaltyVault != address(0) &&IRoyaltyVault(royaltyVault).getVaultBalance() > 0) {IRoyaltyVault(royaltyVault).sendToSplitter();}}}