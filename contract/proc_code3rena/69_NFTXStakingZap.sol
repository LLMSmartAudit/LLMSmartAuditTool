pragma solidity ^0.8.0;import "./interface/INFTXVault.sol";import "./interface/INFTXVaultFactory.sol";import "./interface/INFTXSimpleFeeDistributor.sol";import "./interface/INFTXLPStaking.sol";import "./interface/INFTXInventoryStaking.sol";import "./interface/ITimelockRewardDistributionToken.sol";import "./interface/IUniswapV2Router01.sol";import "./testing/IERC721.sol";import "./token/IERC1155Upgradeable.sol";import "./token/IERC20Upgradeable.sol";import "./token/ERC721HolderUpgradeable.sol";import "./token/ERC1155HolderUpgradeable.sol";import "./util/OwnableUpgradeable.sol";interface IWETH {function deposit() external payable;function transfer(address to, uint value) external returns (bool);function withdraw(uint) external;}abstract contract ReentrancyGuard {uint256 private constant _NOT_ENTERED = 1;uint256 private constant _ENTERED = 2;uint256 private _status;constructor() {_status = _NOT_ENTERED;}modifier nonReentrant() {require(_status != _ENTERED, "ReentrancyGuard: reentrant call");_status = _ENTERED;_;_status = _NOT_ENTERED;}}abstract contract Ownable {address private _owner;event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);constructor() {_setOwner(msg.sender);}function owner() public view virtual returns (address) {return _owner;}modifier onlyOwner() {require(owner() == msg.sender, "Ownable: caller is not the owner");_;}function renounceOwnership() public virtual onlyOwner {_setOwner(address(0));}function transferOwnership(address newOwner) public virtual onlyOwner {require(newOwner != address(0), "Ownable: new owner is the zero address");_setOwner(newOwner);}function _setOwner(address newOwner) private {address oldOwner = _owner;_owner = newOwner;emit OwnershipTransferred(oldOwner, newOwner);}}contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {IWETH public immutable WETH;INFTXLPStaking public immutable lpStaking;INFTXInventoryStaking public immutable inventoryStaking;INFTXVaultFactory public immutable nftxFactory;IUniswapV2Router01 public immutable sushiRouter;uint256 public lpLockTime = 48 hours;uint256 public inventoryLockTime = 7 days;uint256 constant BASE = 10**18;event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {nftxFactory = INFTXVaultFactory(_nftxFactory);lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());sushiRouter = IUniswapV2Router01(_sushiRouter);WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);}function setLPLockTime(uint256 newLPLockTime) external onlyOwner {require(newLPLockTime <= 7 days, "Lock too long");lpLockTime = newLPLockTime;}function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {require(newInventoryLockTime <= 14 days, "Lock too long");inventoryLockTime = newInventoryLockTime;}function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {uint256 count = tokenIds.length;INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);address xToken = inventoryStaking.vaultXToken(vaultId);uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);uint256[] memory amounts = new uint256[](0);address assetAddress = vault.assetAddress();for (uint256 i = 0; i < tokenIds.length; i++) {transferFromERC721(assetAddress, tokenIds[i], address(vault));approveERC721(assetAddress, address(vault), tokenIds[i]);}vault.mintTo(tokenIds, amounts, address(xToken));uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);require(newBal == oldBal + count*BASE, "Incorrect vtokens minted");}function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {uint256 count;for (uint256 i = 0; i < tokenIds.length; i++) {count += amounts[i];}INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);address xToken = inventoryStaking.vaultXToken(vaultId);uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, "");nft.setApprovalForAll(address(vault), true);vault.mintTo(tokenIds, amounts, address(xToken));uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));require(newBal == oldBal + count*BASE, "Incorrect vtokens minted");}function addLiquidity721ETH(uint256 vaultId,uint256[] memory ids,uint256 minWethIn) public payable returns (uint256) {return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);}function addLiquidity721ETHTo(uint256 vaultId,uint256[] memory ids,uint256 minWethIn,address to) public payable nonReentrant returns (uint256) {WETH.deposit{value: msg.value}();(, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);if (amountEth < msg.value) {WETH.withdraw(msg.value-amountEth);payable(to).call{value: msg.value-amountEth};}return liquidity;}function addLiquidity1155ETH(uint256 vaultId,uint256[] memory ids,uint256[] memory amounts,uint256 minEthIn) public payable returns (uint256) {return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);}function addLiquidity1155ETHTo(uint256 vaultId,uint256[] memory ids,uint256[] memory amounts,uint256 minEthIn,address to) public payable nonReentrant returns (uint256) {WETH.deposit{value: msg.value}();(, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);if (amountEth < msg.value) {WETH.withdraw(msg.value-amountEth);payable(to).call{value: msg.value-amountEth};}return liquidity;}function addLiquidity721(uint256 vaultId,uint256[] memory ids,uint256 minWethIn,uint256 wethIn) public returns (uint256) {return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);}function addLiquidity721To(uint256 vaultId,uint256[] memory ids,uint256 minWethIn,uint256 wethIn,address to) public nonReentrant returns (uint256) {IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);(, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);if (amountEth < wethIn) {WETH.transfer(to, wethIn-amountEth);}return liquidity;}function addLiquidity1155(uint256 vaultId,uint256[] memory ids,uint256[] memory amounts,uint256 minWethIn,uint256 wethIn) public returns (uint256) {return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);}function addLiquidity1155To(uint256 vaultId,uint256[] memory ids,uint256[] memory amounts,uint256 minWethIn,uint256 wethIn,address to) public nonReentrant returns (uint256) {IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);(, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);if (amountEth < wethIn) {WETH.transfer(to, wethIn-amountEth);}return liquidity;}function _addLiquidity721WETH(uint256 vaultId,uint256[] memory ids,uint256 minWethIn,uint256 wethIn,address to) internal returns (uint256, uint256, uint256) {address vault = nftxFactory.vault(vaultId);require(vault != address(0), "NFTXZap: Vault does not exist");address assetAddress = INFTXVault(vault).assetAddress();for (uint256 i = 0; i < ids.length; i++) {transferFromERC721(assetAddress, ids[i], vault);approveERC721(assetAddress, vault, ids[i]);}uint256[] memory emptyIds;uint256 count = INFTXVault(vault).mint(ids, emptyIds);uint256 balance = (count * BASE);require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), "Did not receive expected balance");return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);}function _addLiquidity1155WETH(uint256 vaultId,uint256[] memory ids,uint256[] memory amounts,uint256 minWethIn,uint256 wethIn,address to) internal returns (uint256, uint256, uint256) {address vault = nftxFactory.vault(vaultId);require(vault != address(0), "NFTXZap: Vault does not exist");address assetAddress = INFTXVault(vault).assetAddress();IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, "");IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);uint256 count = INFTXVault(vault).mint(ids, amounts);uint256 balance = (count * BASE);require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), "Did not receive expected balance");return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);}function _addLiquidityAndLock(uint256 vaultId,address vault,uint256 minTokenIn,uint256 minWethIn,uint256 wethIn,address to) internal returns (uint256, uint256, uint256) {IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);(uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(address(vault),sushiRouter.WETH(),minTokenIn,wethIn,minTokenIn,minWethIn,address(this),block.timestamp);address lpToken = pairFor(vault, address(WETH));IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);if (amountToken < minTokenIn) {IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);}uint256 lockEndTime = block.timestamp + lpLockTime;emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);return (amountToken, amountEth, liquidity);}function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;bytes memory data;if (assetAddr == kitties) {data = abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, address(this), tokenId);} else if (assetAddr == punks) {bytes memory punkIndexToAddress = abi.encodeWithSignature("punkIndexToAddress(uint256)", tokenId);(bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);(address owner) = abi.decode(result, (address));require(checkSuccess && owner == msg.sender, "Not the owner");data = abi.encodeWithSignature("buyPunk(uint256)", tokenId);} else {data = abi.encodeWithSignature("safeTransferFrom(address,address,uint256)", msg.sender, to, tokenId);}(bool success, bytes memory resultData) = address(assetAddr).call(data);require(success, string(resultData));}function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;bytes memory data;if (assetAddr == kitties) {data = abi.encodeWithSignature("approve(address,uint256)", to, tokenId);} else if (assetAddr == punks) {data = abi.encodeWithSignature("offerPunkForSaleToAddress(uint256,uint256,address)", tokenId, 0, to);} else {return;}(bool success, bytes memory resultData) = address(assetAddr).call(data);require(success, string(resultData));}function pairFor(address tokenA, address tokenB) internal view returns (address pair) {(address token0, address token1) = sortTokens(tokenA, tokenB);pair = address(uint160(uint256(keccak256(abi.encodePacked(hex'ff',sushiRouter.factory(),keccak256(abi.encodePacked(token0, token1)),hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303')))));}function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');}receive() external payable {}function rescue(address token) external onlyOwner {IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));}}