pragma solidity 0.6.12;pragma experimental ABIEncoderV2;import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";import "@boringcrypto/boring-solidity/contracts/Domain.sol";import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";import "./interfaces/IERC721.sol";import "./interfaces/INFTOracle.sol";struct TokenLoanParams {uint128 valuation;uint64 duration;uint16 annualInterestBPS;uint16 ltvBPS;INFTOracle oracle;}struct SignatureParams {uint256 deadline;uint8 v;bytes32 r;bytes32 s;}interface ILendingClub {function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);}interface INFTPair {function collateral() external view returns (IERC721);function asset() external view returns (IERC20);function masterContract() external view returns (address);function bentoBox() external view returns (IBentoBoxV1);function removeCollateral(uint256 tokenId, address to) external;}contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {using BoringMath for uint256;using BoringMath128 for uint128;using RebaseLibrary for Rebase;using BoringERC20 for IERC20;event LogRequestLoan(address indexed borrower,uint256 indexed tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS);event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);event LogRemoveCollateral(uint256 indexed tokenId, address recipient);event LogLend(address indexed lender, uint256 indexed tokenId);event LogRepay(address indexed from, uint256 indexed tokenId);event LogFeeTo(address indexed newFeeTo);event LogWithdrawFees(address indexed feeTo, uint256 feeShare);IBentoBoxV1 public immutable bentoBox;NFTPairWithOracle public immutable masterContract;address public feeTo;IERC721 public collateral;IERC20 public asset;uint256 public feesEarnedShare;mapping(uint256 => TokenLoanParams) public tokenLoanParams;uint8 private constant LOAN_INITIAL = 0;uint8 private constant LOAN_REQUESTED = 1;uint8 private constant LOAN_OUTSTANDING = 2;struct TokenLoan {address borrower;address lender;uint64 startTime;uint8 status;}mapping(uint256 => TokenLoan) public tokenLoan;uint256 private constant PROTOCOL_FEE_BPS = 1000;uint256 private constant OPEN_FEE_BPS = 100;uint256 private constant BPS = 10_000;uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;uint8 private constant COMPOUND_INTEREST_TERMS = 6;mapping(address => uint256) public nonces;constructor(IBentoBoxV1 bentoBox_) public {bentoBox = bentoBox_;masterContract = this;}function init(bytes calldata data) public payable override {require(address(collateral) == address(0), "NFTPair: already initialized");(collateral, asset) = abi.decode(data, (IERC721, IERC20));require(address(collateral) != address(0), "NFTPair: bad pair");}function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {TokenLoan memory loan = tokenLoan[tokenId];if (loan.status == LOAN_OUTSTANDING) {require(msg.sender == loan.lender, "NFTPair: not the lender");TokenLoanParams memory cur = tokenLoanParams[tokenId];require(params.duration >= cur.duration &&params.valuation <= cur.valuation &&params.annualInterestBPS <= cur.annualInterestBPS &&params.ltvBPS <= cur.ltvBPS,"NFTPair: worse params");} else if (loan.status == LOAN_REQUESTED) {require(msg.sender == loan.borrower, "NFTPair: not the borrower");} else {revert("NFTPair: no collateral");}tokenLoanParams[tokenId] = params;emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);}function _requestLoan(address collateralProvider,uint256 tokenId,TokenLoanParams memory params,address to,bool skim) private {require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");if (skim) {require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");} else {collateral.transferFrom(collateralProvider, address(this), tokenId);}TokenLoan memory loan;loan.borrower = to;loan.status = LOAN_REQUESTED;tokenLoan[tokenId] = loan;tokenLoanParams[tokenId] = params;emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);}function requestLoan(uint256 tokenId,TokenLoanParams memory params,address to,bool skim) public {_requestLoan(msg.sender, tokenId, params, to, skim);}function removeCollateral(uint256 tokenId, address to) public {TokenLoan memory loan = tokenLoan[tokenId];if (loan.status == LOAN_REQUESTED) {require(msg.sender == loan.borrower, "NFTPair: not the borrower");} else if (loan.status == LOAN_OUTSTANDING) {require(to == loan.lender, "NFTPair: not the lender");if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {TokenLoanParams memory loanParams = tokenLoanParams[tokenId];uint256 interest = calculateInterest(loanParams.valuation,uint64(block.timestamp - loan.startTime),loanParams.annualInterestBPS).to128();uint256 amount = loanParams.valuation + interest;(, uint256 rate) = loanParams.oracle.get(address(this), tokenId);require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");}}delete tokenLoan[tokenId];collateral.transferFrom(address(this), to, tokenId);emit LogRemoveCollateral(tokenId, to);}function _lend(address lender,uint256 tokenId,TokenLoanParams memory accepted,bool skim) internal {TokenLoan memory loan = tokenLoan[tokenId];require(loan.status == LOAN_REQUESTED, "NFTPair: not available");TokenLoanParams memory params = tokenLoanParams[tokenId];require(params.valuation == accepted.valuation &&params.duration <= accepted.duration &&params.annualInterestBPS >= accepted.annualInterestBPS &&params.ltvBPS >= accepted.ltvBPS,"NFTPair: bad params");if (params.oracle != INFTOracle(0)) {(, uint256 rate) = params.oracle.get(address(this), tokenId);require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");}uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;if (skim) {require(bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),"NFTPair: skim too much");} else {bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);}uint256 borrowerShare = totalShare - openFeeShare;bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);feesEarnedShare += protocolFeeShare;loan.lender = lender;loan.status = LOAN_OUTSTANDING;loan.startTime = uint64(block.timestamp);tokenLoan[tokenId] = loan;emit LogLend(lender, tokenId);}function lend(uint256 tokenId,TokenLoanParams memory accepted,bool skim) public {_lend(msg.sender, tokenId, accepted, skim);}function DOMAIN_SEPARATOR() external view returns (bytes32) {return _domainSeparator();}bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;function requestAndBorrow(uint256 tokenId,address lender,address recipient,TokenLoanParams memory params,bool skimCollateral,bool anyTokenId,SignatureParams memory signature) public {if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");} else {require(block.timestamp <= signature.deadline, "NFTPair: signature expired");uint256 nonce = nonces[lender]++;bytes32 dataHash = keccak256(abi.encode(LEND_SIGNATURE_HASH,address(this),anyTokenId ? 0 : tokenId,anyTokenId,params.valuation,params.duration,params.annualInterestBPS,params.ltvBPS,params.oracle,nonce,signature.deadline));require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");}_requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);_lend(lender, tokenId, params, false);}function takeCollateralAndLend(uint256 tokenId,address borrower,TokenLoanParams memory params,bool skimFunds,SignatureParams memory signature) public {require(block.timestamp <= signature.deadline, "NFTPair: signature expired");uint256 nonce = nonces[borrower]++;bytes32 dataHash = keccak256(abi.encode(BORROW_SIGNATURE_HASH,address(this),tokenId,params.valuation,params.duration,params.annualInterestBPS,params.ltvBPS,params.oracle,nonce,signature.deadline));require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");_requestLoan(borrower, tokenId, params, borrower, false);_lend(msg.sender, tokenId, params, skimFunds);}function calculateInterest(uint256 principal,uint64 t,uint16 aprBPS) public pure returns (uint256 interest) {uint256 x = uint256(t) * aprBPS;uint256 term_k = (principal * x) / YEAR_BPS;uint256 denom_k = YEAR_BPS;interest = term_k;for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {denom_k += YEAR_BPS;term_k = (term_k * x) / denom_k;interest = interest.add(term_k);}if (interest >= 2**128) {revert();}}function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {TokenLoan memory loan = tokenLoan[tokenId];require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");TokenLoanParams memory loanParams = tokenLoanParams[tokenId];require(uint256(loan.startTime) + loanParams.duration > block.timestamp,"NFTPair: loan expired");uint128 principal = loanParams.valuation;uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;amount = principal + interest;uint256 totalShare = bentoBox.toShare(asset, amount, false);uint256 feeShare = bentoBox.toShare(asset, fee, false);address from;if (skim) {require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");from = address(this);} else {bentoBox.transfer(asset, msg.sender, address(this), feeShare);from = msg.sender;}feesEarnedShare += feeShare;delete tokenLoan[tokenId];bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);collateral.transferFrom(address(this), loan.borrower, tokenId);emit LogRepay(from, tokenId);}uint8 internal constant ACTION_REPAY = 2;uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;uint8 internal constant ACTION_REQUEST_LOAN = 12;uint8 internal constant ACTION_LEND = 13;uint8 internal constant ACTION_BENTO_DEPOSIT = 20;uint8 internal constant ACTION_BENTO_WITHDRAW = 21;uint8 internal constant ACTION_BENTO_TRANSFER = 22;uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;uint8 internal constant ACTION_CALL = 30;uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;int256 internal constant USE_VALUE1 = -1;int256 internal constant USE_VALUE2 = -2;function _num(int256 inNum,uint256 value1,uint256 value2) internal pure returns (uint256 outNum) {outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);}function _bentoDeposit(bytes memory data,uint256 value,uint256 value1,uint256 value2) internal returns (uint256, uint256) {(IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errorsshare = int256(_num(share, value1, value2));return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));}function _bentoWithdraw(bytes memory data,uint256 value1,uint256 value2) internal returns (uint256, uint256) {(IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));}function _call(uint256 value,bytes memory data,uint256 value1,uint256 value2) internal returns (bytes memory, uint8) {(address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(data,(address, bytes, bool, bool, uint8));if (useValue1 && !useValue2) {callData = abi.encodePacked(callData, value1);} else if (!useValue1 && useValue2) {callData = abi.encodePacked(callData, value2);} else if (useValue1 && useValue2) {callData = abi.encodePacked(callData, value1, value2);}require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");(bool success, bytes memory returnData) = callee.call{value: value}(callData);require(success, "NFTPair: call failed");return (returnData, returnValues);}function cook(uint8[] calldata actions,uint256[] calldata values,bytes[] calldata datas) external payable returns (uint256 value1, uint256 value2) {for (uint256 i = 0; i < actions.length; i++) {uint8 action = actions[i];if (action == ACTION_REPAY) {(uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));repay(tokenId, skim);} else if (action == ACTION_REMOVE_COLLATERAL) {(uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));removeCollateral(tokenId, to);} else if (action == ACTION_REQUEST_LOAN) {(uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(datas[i],(uint256, TokenLoanParams, address, bool));requestLoan(tokenId, params, to, skim);} else if (action == ACTION_LEND) {(uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));lend(tokenId, params, skim);} else if (action == ACTION_BENTO_SETAPPROVAL) {(address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(datas[i],(address, address, bool, uint8, bytes32, bytes32));bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);} else if (action == ACTION_BENTO_DEPOSIT) {(value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);} else if (action == ACTION_BENTO_WITHDRAW) {(value1, value2) = _bentoWithdraw(datas[i], value1, value2);} else if (action == ACTION_BENTO_TRANSFER) {(IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));} else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {(IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));bentoBox.transferMultiple(token, msg.sender, tos, shares);} else if (action == ACTION_CALL) {(bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);if (returnValues == 1) {(value1) = abi.decode(returnData, (uint256));} else if (returnValues == 2) {(value1, value2) = abi.decode(returnData, (uint256, uint256));}} else if (action == ACTION_REQUEST_AND_BORROW) {(uint256 tokenId,address lender,address recipient,TokenLoanParams memory params,bool skimCollateral,bool anyTokenId,SignatureParams memory signature) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);} else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {(uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi.decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);}}}function withdrawFees() public {address to = masterContract.feeTo();uint256 _share = feesEarnedShare;if (_share > 0) {bentoBox.transfer(asset, address(this), to, _share);feesEarnedShare = 0;}emit LogWithdrawFees(to, _share);}function setFeeTo(address newFeeTo) public onlyOwner {feeTo = newFeeTo;emit LogFeeTo(newFeeTo);}}