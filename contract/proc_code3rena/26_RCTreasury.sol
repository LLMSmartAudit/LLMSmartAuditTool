pragma solidity 0.8.7;import "@openzeppelin/contracts/access/AccessControl.sol";import "@openzeppelin/contracts/utils/math/SafeCast.sol";import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";import "hardhat/console.sol";import "./lib/NativeMetaTransaction.sol";import "./interfaces/IRCTreasury.sol";import "./interfaces/IRCMarket.sol";import "./interfaces/IRCOrderbook.sol";import "./interfaces/IRCNftHubL2.sol";import "./interfaces/IRCFactory.sol";import "./interfaces/IRCBridge.sol";contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {using SafeERC20 for IERC20;IRCOrderbook public override orderbook;IRCLeaderboard public override leaderboard;IERC20 public override erc20;address public override bridgeAddress;IRCFactory public override factory;uint256 public override totalDeposits;mapping(address => uint256) public override marketPot;uint256 public override totalMarketPots;uint256 public override marketBalance;mapping(address => bool) public override isForeclosed;uint256 public override marketBalanceTopup;struct User {uint128 deposit;uint128 rentalRate;uint128 bidRate;uint64 lastRentCalc;uint64 lastRentalTime;}mapping(address => User) public user;uint256 public override minRentalDayDivisor;uint256 public override maxContractBalance;mapping(address => bool) public isAllowed;bool public whitelistEnabled;mapping(address => bytes32) public marketWhitelist;bool public override globalPause;mapping(address => bool) public override marketPaused;mapping(address => bool) public override lockMarketPaused;bytes32 public constant UBER_OWNER = keccak256("UBER_OWNER");bytes32 public constant OWNER = keccak256("OWNER");bytes32 public constant GOVERNOR = keccak256("GOVERNOR");bytes32 public constant FACTORY = keccak256("FACTORY");bytes32 public constant MARKET = keccak256("MARKET");bytes32 public constant TREASURY = keccak256("TREASURY");bytes32 public constant ORDERBOOK = keccak256("ORDERBOOK");bytes32 public constant WHITELIST = keccak256("WHITELIST");bytes32 public constant ARTIST = keccak256("ARTIST");bytes32 public constant AFFILIATE = keccak256("AFFILIATE");bytes32 public constant CARD_AFFILIATE = keccak256("CARD_AFFILIATE");event LogUserForeclosed(address indexed user, bool indexed foreclosed);event LogAdjustDeposit(address indexed user,uint256 indexed amount,bool increase);event LogMarketPaused(address market, bool paused);event LogGlobalPause(bool paused);event LogWhitelistUser(address user, bool allowed);constructor(address _tokenAddress) {_initializeEIP712("RealityCardsTreasury", "1");_setupRole(DEFAULT_ADMIN_ROLE, _msgSender());_setupRole(UBER_OWNER, _msgSender());_setupRole(OWNER, _msgSender());_setupRole(GOVERNOR, _msgSender());_setupRole(WHITELIST, _msgSender());_setupRole(TREASURY, address(this));_setRoleAdmin(UBER_OWNER, UBER_OWNER);_setRoleAdmin(OWNER, UBER_OWNER);_setRoleAdmin(FACTORY, UBER_OWNER);_setRoleAdmin(ORDERBOOK, UBER_OWNER);_setRoleAdmin(TREASURY, UBER_OWNER);_setRoleAdmin(GOVERNOR, OWNER);_setRoleAdmin(WHITELIST, GOVERNOR);_setRoleAdmin(ARTIST, GOVERNOR);_setRoleAdmin(AFFILIATE, GOVERNOR);_setRoleAdmin(CARD_AFFILIATE, GOVERNOR);_setRoleAdmin(MARKET, FACTORY);setMinRental(24 * 6);setMaxContractBalance(1_000_000 ether);setTokenAddress(_tokenAddress);whitelistEnabled = true;}modifier balancedBooks() {_;require(erc20.balanceOf(address(this)) >=totalDeposits + marketBalance + totalMarketPots,"Books are unbalanced!");}function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {minRentalDayDivisor = _newDivisor;}function setMaxContractBalance(uint256 _newBalanceLimit)publicoverrideonlyRole(OWNER){maxContractBalance = _newBalanceLimit;}function changeGlobalPause() external override onlyRole(OWNER) {globalPause = !globalPause;emit LogGlobalPause(globalPause);}function changePauseMarket(address _market, bool _paused)externaloverrideonlyRole(OWNER){require(hasRole(MARKET, _market), "This isn't a market");marketPaused[_market] = _paused;lockMarketPaused[_market] = marketPaused[_market];emit LogMarketPaused(_market, marketPaused[_market]);}function unPauseMarket(address _market)externaloverrideonlyRole(FACTORY){require(hasRole(MARKET, _market), "This isn't a market");require(!lockMarketPaused[_market], "Owner has paused market");marketPaused[_market] = false;emit LogMarketPaused(_market, marketPaused[_market]);}function toggleWhitelist() external override onlyRole(OWNER) {whitelistEnabled = !whitelistEnabled;}function batchWhitelist(address[] calldata _users, bool add)externaloverrideonlyRole(GOVERNOR){if (add) {for (uint256 index = 0; index < _users.length; index++) {RCTreasury.grantRole(WHITELIST, _users[index]);}} else {for (uint256 index = 0; index < _users.length; index++) {RCTreasury.revokeRole(WHITELIST, _users[index]);}}}function marketWhitelistCheck(address _user)externalviewoverridereturns (bool){bytes32 requiredRole = marketWhitelist[msgSender()];if (requiredRole == bytes32(0)) {return true;} else {return hasRole(requiredRole, _user);}}function setFactoryAddress(address _newFactory)externaloverrideonlyRole(UBER_OWNER){require(_newFactory != address(0), "Must set an address");revokeRole(FACTORY, address(factory));revokeRole(OWNER, address(factory));revokeRole(GOVERNOR, address(factory));factory = IRCFactory(_newFactory);grantRole(FACTORY, address(factory));grantRole(OWNER, address(factory));grantRole(GOVERNOR, address(factory));}function setOrderbookAddress(address _newOrderbook)externaloverrideonlyRole(UBER_OWNER){require(_newOrderbook != address(0), "Must set an address");revokeRole(ORDERBOOK, address(orderbook));orderbook = IRCOrderbook(_newOrderbook);grantRole(ORDERBOOK, address(orderbook));factory.setOrderbookAddress(orderbook);}function setLeaderboardAddress(address _newLeaderboard)externaloverrideonlyRole(UBER_OWNER){require(_newLeaderboard != address(0), "Must set an address");leaderboard = IRCLeaderboard(_newLeaderboard);factory.setLeaderboardAddress(leaderboard);}function setTokenAddress(address _newToken)publicoverrideonlyRole(UBER_OWNER){require(_newToken != address(0), "Must set an address");erc20 = IERC20(_newToken);}function setBridgeAddress(address _newBridge)externaloverrideonlyRole(UBER_OWNER){require(_newBridge != address(0), "Must set an address");bridgeAddress = _newBridge;erc20.approve(_newBridge, type(uint256).max);}function globalExit() external onlyRole(UBER_OWNER) {uint256 _balance = erc20.balanceOf(address(this));erc20.safeTransfer(msg.sender, _balance);}function deposit(uint256 _amount, address _user)externaloverridebalancedBooksreturns (bool){require(!globalPause, "Deposits are disabled");require(erc20.allowance(msgSender(), address(this)) >= _amount,"User not approved to send this amount");require((erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,"Limit hit");require(_amount > 0, "Must deposit something");if (whitelistEnabled) {require(hasRole(WHITELIST, _user), "Not in whitelist");}erc20.safeTransferFrom(msgSender(), address(this), _amount);orderbook.removeOldBids(_user);user[_user].deposit += SafeCast.toUint128(_amount);totalDeposits += _amount;emit LogAdjustDeposit(_user, _amount, true);assessForeclosure(_user);return true;}function withdrawDeposit(uint256 _amount, bool _localWithdrawal)externaloverridebalancedBooks{require(!globalPause, "Withdrawals are disabled");address _msgSender = msgSender();require(user[_msgSender].deposit > 0, "Nothing to withdraw");require(user[_msgSender].bidRate == 0 ||block.timestamp - (user[_msgSender].lastRentalTime) >uint256(1 days) / minRentalDayDivisor,"Too soon");collectRentUser(_msgSender, block.timestamp);if (_amount > user[_msgSender].deposit) {_amount = user[_msgSender].deposit;}emit LogAdjustDeposit(_msgSender, _amount, false);user[_msgSender].deposit -= SafeCast.toUint128(_amount);totalDeposits -= _amount;if (_localWithdrawal) {erc20.safeTransfer(_msgSender, _amount);} else {IRCBridge bridge = IRCBridge(bridgeAddress);bridge.withdrawToMainnet(_msgSender, _amount);}orderbook.removeOldBids(_msgSender);if (user[_msgSender].bidRate != 0 &&user[_msgSender].bidRate / (minRentalDayDivisor) >user[_msgSender].deposit) {isForeclosed[_msgSender] = true;orderbook.removeUserFromOrderbook(_msgSender);}}function topupMarketBalance(uint256 _amount)externaloverridebalancedBooks{erc20.safeTransferFrom(msgSender(), address(this), _amount);marketBalanceTopup += _amount;marketBalance += _amount;}function checkSponsorship(address sender, uint256 _amount)externalviewoverride{require(erc20.allowance(sender, address(this)) >= _amount,"Insufficient Allowance");require(erc20.balanceOf(sender) >= _amount, "Insufficient Balance");}function payRent(uint256 _amount)externaloverridebalancedBooksonlyRole(MARKET)returns (uint256){require(!globalPause, "Rentals are disabled");if (marketBalance < _amount) {uint256 discrepancy = _amount - marketBalance;if (discrepancy > marketBalanceTopup) {marketBalanceTopup = 0;} else {marketBalanceTopup -= discrepancy;}_amount = marketBalance;}address _market = msgSender();marketBalance -= _amount;marketPot[_market] += _amount;totalMarketPots += _amount;return _amount;}function payout(address _user, uint256 _amount)externaloverridebalancedBooksonlyRole(MARKET)returns (bool){require(!globalPause, "Payouts are disabled");user[_user].deposit += SafeCast.toUint128(_amount);marketPot[msgSender()] -= _amount;totalMarketPots -= _amount;totalDeposits += _amount;assessForeclosure(_user);emit LogAdjustDeposit(_user, _amount, true);return true;}function refundUser(address _user, uint256 _refund)externaloverridebalancedBooksonlyRole(MARKET){marketBalance -= _refund;user[_user].deposit += SafeCast.toUint128(_refund);totalDeposits += _refund;emit LogAdjustDeposit(_user, _refund, true);assessForeclosure(_user);}function sponsor(address _sponsor, uint256 _amount)externaloverridebalancedBooksonlyRole(MARKET){require(!globalPause, "Global Pause is Enabled");address _msgSender = msgSender();require(!lockMarketPaused[_msgSender], "Market is paused");require(erc20.allowance(_sponsor, address(this)) >= _amount,"Not approved to send this amount");erc20.safeTransferFrom(_sponsor, address(this), _amount);marketPot[_msgSender] += _amount;totalMarketPots += _amount;}function updateLastRentalTime(address _user)externaloverrideonlyRole(MARKET){user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);if (user[_user].lastRentCalc == 0) {user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);}}function addMarket(address _market, bool _paused) external override {require(hasRole(FACTORY, msgSender()), "Not Authorised");marketPaused[_market] = _paused;AccessControl.grantRole(MARKET, _market);emit LogMarketPaused(_market, marketPaused[_market]);}function userTotalBids(address _user)externalviewoverridereturns (uint256){return user[_user].bidRate;}function userDeposit(address _user)externalviewoverridereturns (uint256){return uint256(user[_user].deposit);}function updateRentalRate(address _oldOwner,address _newOwner,uint256 _oldPrice,uint256 _newPrice,uint256 _timeOwnershipChanged) external override onlyRole(ORDERBOOK) {if (_timeOwnershipChanged != user[_newOwner].lastRentCalc &&!hasRole(MARKET, _newOwner)) {if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {uint256 _additionalRentOwed = rentOwedBetweenTimestamps(user[_newOwner].lastRentCalc,_timeOwnershipChanged,_newPrice);_increaseMarketBalance(_additionalRentOwed, _newOwner);emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);} else {if (user[_newOwner].rentalRate != 0) {collectRentUser(_newOwner, _timeOwnershipChanged);} else {user[_newOwner].lastRentCalc = SafeCast.toUint64(_timeOwnershipChanged);emit LogAdjustDeposit(_newOwner, 0, false);}}}user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);}function increaseBidRate(address _user, uint256 _price)externaloverrideonlyRole(ORDERBOOK){user[_user].bidRate += SafeCast.toUint128(_price);}function decreaseBidRate(address _user, uint256 _price)externaloverrideonlyRole(ORDERBOOK){user[_user].bidRate -= SafeCast.toUint128(_price);}function rentOwedUser(address _user, uint256 _timeOfCollection)internalviewreturns (uint256 rentDue){return(user[_user].rentalRate *(_timeOfCollection - user[_user].lastRentCalc)) / (1 days);}function rentOwedBetweenTimestamps(uint256 _time1,uint256 _time2,uint256 _price) internal pure returns (uint256 _rent) {if (_time1 < _time2) {(_time1, _time2) = (_time2, _time1);}_rent = (_price * (_time1 - _time2)) / (1 days);}function foreclosureTimeUser(address _user,uint256 _newBid,uint256 _timeOfNewBid) external view override returns (uint256) {uint256 totalUserDailyRent = user[_user].rentalRate;if (totalUserDailyRent > 0) {uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /totalUserDailyRent;uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +timeLeftOfDeposit;if (foreclosureTimeWithoutNewCard > _timeOfNewBid &&_timeOfNewBid != 0) {uint256 _rentDifference = rentOwedBetweenTimestamps(user[_user].lastRentCalc,_timeOfNewBid,totalUserDailyRent);uint256 _depositAtTimeOfNewBid = 0;if (user[_user].lastRentCalc < _timeOfNewBid) {_depositAtTimeOfNewBid =user[_user].deposit -_rentDifference;} else {_depositAtTimeOfNewBid =user[_user].deposit +_rentDifference;}uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *1 days) / (totalUserDailyRent + _newBid);uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +_timeLeftOfDepositWithNewBid;if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {return _foreclosureTimeWithNewCard;} else {return 0;}} else {return user[_user].lastRentCalc + timeLeftOfDeposit;}} else {if (_newBid == 0) {return type(uint256).max;} else {return_timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);}}}function collectRentUser(address _user, uint256 _timeToCollectTo)publicoverridereturns (uint256 newTimeLastCollectedOnForeclosure){require(!globalPause, "Global pause is enabled");require(_timeToCollectTo != 0, "Must set collection time");require(_timeToCollectTo <= block.timestamp,"Can't collect future rent");if (user[_user].lastRentCalc < _timeToCollectTo) {uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {uint256 previousCollectionTime = user[_user].lastRentCalc;timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)= (now - previousCollectionTime) * (usersDeposit/rentOwed)uint256 timeUsersDepositLasts = ((_timeToCollectTo -previousCollectionTime) * uint256(user[_user].deposit)) /rentOwedByUser;Users last collection time = previousCollectionTime + timeTheirDepositLastedrentOwedByUser = uint256(user[_user].deposit);newTimeLastCollectedOnForeclosure =previousCollectionTime +timeUsersDepositLasts;_increaseMarketBalance(rentOwedByUser, _user);user[_user].lastRentCalc = SafeCast.toUint64(newTimeLastCollectedOnForeclosure);assert(user[_user].deposit == 0);isForeclosed[_user] = true;emit LogUserForeclosed(_user, true);} else {_increaseMarketBalance(rentOwedByUser, _user);user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);}emit LogAdjustDeposit(_user, rentOwedByUser, false);}}function _increaseMarketBalance(uint256 rentCollected, address _user)internal{marketBalance += rentCollected;user[_user].deposit -= SafeCast.toUint128(rentCollected);totalDeposits -= rentCollected;}function assessForeclosure(address _user) public override {if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {isForeclosed[_user] = false;emit LogUserForeclosed(_user, false);} else {isForeclosed[_user] = true;emit LogUserForeclosed(_user, true);}}function checkPermission(bytes32 role, address account)externalviewoverridereturns (bool){return AccessControl.hasRole(role, account);}function grantRole(string memory role, address account) external override {bytes32 _role = keccak256(abi.encodePacked(role));RCTreasury.grantRole(_role, account);}function grantRole(bytes32 role, address account)publicoverride(AccessControl, IRCTreasury){if (role == WHITELIST) {emit LogWhitelistUser(account, true);}AccessControl.grantRole(role, account);}function revokeRole(string memory role, address account) external override {bytes32 _role = keccak256(abi.encodePacked(role));RCTreasury.revokeRole(_role, account);}function revokeRole(bytes32 role, address account)publicoverride(AccessControl, IRCTreasury){if (role == WHITELIST) {emit LogWhitelistUser(account, false);}AccessControl.revokeRole(role, account);}}